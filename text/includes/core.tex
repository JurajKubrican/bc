\section{Analıza problému}
%Súèasnı stav riešenej problematiky
\noindent 


\subsection{Relaèné databázy}
\label{relational}
\noindent Relaèná databáza je databáza, v ktorej sú údaje uloené pod¾a relaèného databázového modelu\cite{codd} pod¾a E. F. Codda z roku 1970. Pod¾a Relaèného modelu sú dáta uloené v tabu¾kách. Jeden riadok tabu¾ky je jeden záznam. Ståpec tabu¾ky reprezentuje jeden atribút objektu.
Väzby (vzahy) medzi tabu¾ami sú riešené pomocou unikátnych identifikátorov tzv. k¾úèov. Jedna tabu¾ka obsahuje k¾úè, èo je atribút ktorı unikátne identifikuje kadı záznam a druhá tabu¾a obsahuje tzv. cudzí k¾úè, atribút ktorı odkazuje na záznam v prvej tabu¾ke.
Nevıhoda tohto prístupu sa však ukazuje v škálovate¾nosti. Pri vyh¾adávaní kadé toto prepojenie pridáva vıpoètovú komplexitu, keïe v kadej ïalšej prepojenej tabu¾ke treba vyh¾ada záznam s poadovanım k¾úèom $O(log(n))$. Všetky pouívané relaèné databázové systémy riešia tento problém škálovate¾nosti pouitím indexov a rôznymi inımi nedeterministickımi optimalizáciami, no pokia¾ sú naše dáta štruktúrované s ve¾kım mnostvom vzahov systém sa spravidla spomalí.

\subsection{Grafovı model}
\noindent Modelovanie grafovej databázy prirodzene zapadá do spôsobu akım bene abstrahujeme problémy pri vıvoji softvéru. Pri návrhu  softvéru objekty opisujeme obdånikmi alebo kruhmi a súvislosti medzi nimi šípkami, èi èiarami. Moderné grafové databázy sú viac ako akáko¾vek iná databázová technológia vhodné na takúto reprezentáciu, lebo to, èo namodelujeme na papier vieme priamo neimplementova v našej grafovej databáze.

Grafové databázy vyuívajú model ktorı pozostáva z vrcholov, hrán, atribútov a znaèiek. Vrcholy obsahujú atribúty, a sú oznaèené jednou alebo viacerımi znaèkami. Tieto znaèky zoskupujú vrcholy, ktoré zastávajú rovnakú rolu v rámci aplikácie.

Hrany v grafovıch databázach spájajú vrcholy a budujú štruktúru grafu. Hrana grafu má vdy smer, názov, vıchodzí vrchol, cie¾ovı vrchol a cie¾ovı vrchol. Fakt, e hany musia ma smer a názov pridáva to sémantickú preh¾adnos do grafu, ak zvolíme správne názov vieme rıchlo identifikova štruktúru grafu a identifikova vıznam vzahov. Hrany môu rovnako ako vrcholy obsahova aj atribúty. Atribúty v hranách môu by praktické na pridanie kvalitatívnych dát (napr. váha, vzdialenos) ku vzahom, tieto dáta sa potom môu poui pri preh¾adávaní grafu.

\subsection{Vıkon grafovej databázy}
\noindent Ako sme u spomínali v èasti \ref{relational} preh¾adanie kadého ïalšieho vzahu v relaènej databáze má teoretickú vıpoètovú zloitos $O(log(n))$. Na druhej strane natívne grafové databázy pouívajú bez indexovú pri¾ahlos \cite{graphDBs}. Toto v praxi znamená, e pri preh¾adávaní vzahov v klesá vıpoètová zloitos na $O(1)$. Táto rıchlos je dosiahnutá tak, e všetky hrany sú uloené s priamymi ukazovate¾mi na vrcholy, ktorıch vzah reprezentujú. Tak isto vo vrcholoch sú uloené priame ukazovatele na všetky hrany vychádzajúce z a mieriace do dotyèného vrcholu. Takáto štruktúra poskytuje u spomínanú vıpoètovú zloitos $O(1)$ v oboch smeroch hrany, take nielen v smere z vıchodzieho bodu do cie¾ového ale aj opaènım smerom. Pri relaènej databáze by toto muselo by riešené reverznım vyh¾adávaním v cudzích k¾úèoch.


\section{Špecifikácia}
\noindent Aplikácia ktorú sme sa rozhodli implementova bude slúi na plánovanie a optimalizáciu trasy cestovate¾a po svete. Dáta našej aplikácie budú teda pozostáva z pouívate¾ov, destinácií a prepojeniami medzi nimi. Štruktúra grafovej databázy je obzvláš vhodná na návrh a  implementáciu prepojení medzi jednotlivımi mestami, keïe tento model má presne štruktúru  klasického grafu. 
%TODO SPECIFIKACIA

\begin{enumerate}
	\item Funkcionálne poiadavky
	\begin{enumerate}
		\item Aplikácia bude umoòova registráciu a prihlásenie pouívate¾a
		\item Pri registrácií sa budú vyadova prihlasovacie údaje: e-mail, heslo. Okrem toho sa bude vyadova zdanie mena a domáceho miesta. Toto domáce miesto bude moné vyh¾ada v online databáze.
		\item Po prihlásení pouívate¾a sa mu zobrazí obrazovka s mapou, zoznamom ob¾úbenıch destinácií, ktoré chce navštívi a zoznam odporúèanıch destinácií
		\item Na mape bude vyobrazené pouívate¾ove domáce miesto a všetky destinácie ktoré ma v zozname ob¾úbenıch destinácií. Po kliknutí na destináciu sa pouívate¾ovi otvorí príslušnı riadok v zozname ob¾úbenıch.
		\item V zozname ob¾úbenıch budú všetky miesta, ktoré si pouívate¾ pridal. Zoznam bude vo forme tabu¾ky riadok bude obsahova Meno destinácie a lokalitu v ktorej sa destinácia nachádza. V riadku tie bude tlaèidlo na vymazanie destinácie z ob¾úbenıch a tlaèidlo na zobrazenie detailov.
		\item V detailoch ob¾úbeného miesta bude zoznam ostatnıch ¾udí ktorí dané miesto majú v ob¾úbenıch a vıpis monıch trás z domáceho miesta pouívate¾a do destinácie.
		\item V zozname odporúèanıch destinácií budú destinácie ktoré majú v ob¾úbenıch pouívatelia, ktorí majú v ob¾úbenıch rovnaké miesta ako miesta, ktoré má v ob¾úbenıch prihlásenı pouívate¾. Vynechané budú miesta, ktoré u prihlásenı pouívate¾ má ob¾úbenıch. Kadá poloka z odporúèanıch sa bude da jednoducho prida do ob¾úbenıch prihláseného pouívate¾a.
		\item V aplikácií bude obrazovka s nastaveniami, na ktorej si bude èlovek môc zmeni heslo, domáce miesto.
		\item V aplikácií bude obrazovka kde si bude pouívate¾ vybra nako¾ko zo svojich ob¾úbenıch miest a necha si vyráta najkratšiu trasu z domáceho miesta cez všetky zvolené miesta a potom spa. (TSP)
		
		
		
	\end{enumerate}
	\item Nefunkcionálne poiadavky
	\begin{enumerate}
		\item Systém bude zrealizovanı na webovej platforme.
		\item Aplikácia bude vyuíva natívnu grafovú databázu.
		\item Aplikácia bude by kompatibilná s webovımi prehliadaèmi Google Chrome Mozilla Firefox, Microsoft Edge, Microsoft Internet Explorer.
		\item Uívate¾ské rozhranie systém musí by plne pouite¾né aj na mobilnıch telefónoch s OS Android a IOS.
		\item Aplikácia bude implementovanı s pouitím jazyka PHP a PHP frameworku.
		\item Systém bude nasadenı na virtuálnom serveri s operaènım systémom Ubuntu 16.04.2 LTS poskytnutom Ústavom informatiky a matematiky FEI STU.
	\end{enumerate}
	
\end{enumerate}


\section{Návrh}
%TODO NAVRH PO KAPITOLE
\noindent V tejto kapitole si priblíime proces návrhu našej aplikácie, popíšeme prípady pouitia ktoré pre našu aplikáciu oèakávame. Ïalej priblíime návrh štruktúry databázy, ktorú plánujeme poui.

\subsubsection{Prípady pouitia}
\noindent Prípady pouitia popisujú interakcie medzi aplikáciou a pouívate¾om, popisujú roly, ktoré rôzny hráèi hrajú v tıchto interakciách. 

\begin{enumerate}
	\item	V prvom prípade pouitia \ref{usecase-login} si bude môc neprihlásenı pouívate¾ prezera mapu a zoznam najpopulárnejších destinácií v našej aplikácií, ïalej sa môe prihlási zaregistrova a poiada o obnovu hesla.
	
	\item	Ïalší prípad pouitia \ref{usecase-settings} opisuje nastavenia. Pouívate¾ si bude môc vyh¾ada destináciu a zvoli si ju ako svoje domáce miesto alebo si zmeni heslo.
	
	\item	Tretí prípad pouitia \ref{usecase-dash} opisuje akcie ktoré bude môc pouívate¾ vykonáva na hlavnej stránke. Bude môc vyh¾adáva destinácie a pridáva si ich do ob¾úbenıch. Destinácie ktoré má v ob¾úbenıch bude môc maza a zobrazi detaily trasy, ktorá k destinácií vedie. Ïalej si bude môc prezera ostatnıch pouívate¾ov ktorı majú rovnaké miesto v ob¾úbenıch a prejs na zoznam ob¾úbenıch destinácií jedného s tıchto pouívate¾ov.
	
	\item	Poslednı prípad pouitia \ref{usecase-tsp} popisuje obrazovku TSP. Na tejto obrazovke bude môc pouívate¾ prezera svoju mapu optimálnej cestovate¾skej trasy, pridáva a odobera z trasy destinácie zo zoznamu ob¾úbenıch.
\end{enumerate}


\begin{figure}
	\centering
	\includegraphics[width=6cm]{uml/usecase-login.pdf}
	\caption{Prípad pouitia - Registrácia, autentifikácia a nastavenia}
	\label{usecase-login}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=6cm]{uml/usecase-settings.pdf}
	\caption{Prípad pouitia - Registrácia, autentifikácia a nastavenia}
	\label{usecase-settings}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=7cm]{uml/usecase-dash.pdf}
	\caption{Prípad pouitia - dashboard}
	\label{usecase-dash}
\end{figure}
\begin{figure}
	\centering
	\includegraphics[width=6cm]{uml/usecase-tsp.pdf}
	\caption{Prípad pouitia - tsp}
	\label{usecase-tsp}
\end{figure}

\subsubsection{Štruktúra databázy}
\noindent Na obrázku è. \ref{database-diagram} našej databáze sa budú nachádza dve hlavné entity: entita pouívate¾a \textit{appUser} a entita destinácie \textit{appPlace}. Entita pouívate¾a bude obsahova iba základné atribúty ako meno a atribúty potrebné pre autentifikáciu pouívate¾a email, a heslo. 
Entita destinácie bude obsahova atribúty potrebné na identifikáciu tejto destinácie: unikátny názov a krátky názov vhodnı na zobrazovanie a atribúty potrebné na lokalizáciu destinácie: zemepisná šírka a zemepisná dåka. 
Keïe pouijeme grafovú databázu nebude potrebné pridáva cudzie k¾úèe reprezentujúce ich vzahy.

Ïalej bude naša databáza obsahova hrany: trasa \textit{ROUTE}, ob¾úbené \textit{FOLLOWS}, a zoznam pre optimalizáciu trasy \textit{TSP}.
Hrana trasy bude vdy vies od jedného miesta k druhému reprezentuje zoznam trás ktoré budú vies od jednej destinácie k druhı. Bude obsahova atribút \textit{minPrice} hovoriaci o cene najlacnejšej trasy medzi spomínanımi destináciami a tribút \textit{routes} obsahujúci serializované detaily všetkıch trás.
%todo this is an optimalization since neo4j sasves oly one attribute in graph 
Hrany \textit{FOLLOWS} a \textit{TSP} budú vdy smerova od pouívate¾a k destinácií a nebudú obsahova iadne atribúty.

\begin{figure}
	\centering
	\makebox[\textwidth]{\includegraphics[width=6cm]{uml/database.pdf}} 
	\caption{Class diagram}
	\label{database-diagram}
\end{figure}



\subsection{Vıber grafovej databázy} 
\noindent Vybrali sme si troch najpopulárnejších predstavite¾ov grafovıch databáz pod¾a rebríèka DB-Engines.com\cite{dbrank}. V nasledujúcej èasti v skratke priblíime históriu kadej grafovej databázy ich vıhody, nevıhody pre naše pouitie.

%TODO citations

\subsubsection{NEO4J}Prvá verzia Neo4J bola vydaná v roku 2007 od vtedy sa stala dlhodobo najpouívanejšou grafovou databázou. Je vyvíjaná Neo Technology, Inc. Neo4j je ponúkaná v dvoch variantoch': Neo4j Community je open source (GPLv3) grafová databáza obsahujúca všetky základné funkcií (Ïalej budeme spomína len túto verziu). A Neo4j Enterprise edícia, ktorá má rozšírené funkcie ako shardovanie cache pamäte, rozšírené monitorovanie a zálohovanie za behu.

Medzi hlavné vıhody neo4j patrí to, e je to dlhodobo najrozšírenejšia grafová databáza, má dobrú dokumentáciu a natívne podporuje OGM (mapovanie objektov na graf) mapovanie dát na objekty. Práve táto natívna podpora OGM umonila vzniku preh¾adného a nástroja NeoEloquent, ktorı sa dá vyui na integrácie Neo4J do frameworku Laravel. 
Ïalšou vıhodou je dopytovací jazyk Cypher, ktorı táto databáza môe vyuíva. Tento jazyk má širokú, preh¾adnú dokumentáciu.
Nevıhodou je, e podporuje iba grafovı model ukladania údajov, nepodporuje ukladanie dokumentov ani key-value úloisko.

\subsubsection{OrientDB}OrientDB je vyvíjané od roku 2010 firmou OrientDB LTD. Databáza OrientDB rıchlo nabralo nabrala na popularite a v roku 2015 sa dostala na druhé miesto v rebríèku DB-engines. OrientDB sa rovnako ako Neo4j distribuuje v dvoch edíciách: Community - open source (Apache Licence 2.0) so základnımi funkciami a Enterprise edíciou s podporou migrácie a synchronizácie na Neo4J a pridanımi analytickımi nástrojmi.

Vıhodou OrientDB je podpora okrem grafového modelu ukladania dát aj dokumentové a key-value úloisko a pod¾a nezávislıch testov \cite{dbspeed} je v niektorıch testoch a desa krát rıchlejšie ako Neo4J.
Nevıhodou OrientDB je horšia dokumentácia a nástroj na integráciu to frameworku Laravel \textit{oriquent} \cite{oriquent} nepodporuje zapisovanie a èítanie z atribútov hrán.

\subsubsection{Titan} Titan bol od 2012 vyvíjanı skupinou ThinkAurelius, no v roku 2017 bol odkúpenı firmou Datstax a projekt Titan bol zastavenı. Projekt je ïalej udriavanı ako open source verzia pod menom JanusGraph. Titan je projekt urèenı na ve¾ké distribuovane enterprise riešenia, je nasadzovanı na cloudové platformy ako napr. Apache Hadoop a Apache Spark  podporuje rôzne distribuované úloné priestory ako napr. Apache HBase a Oracle BerkeleyDB Ïalej podporuje rôzne vyh¾adávacie enginy ako napr. Elasticsearch a Solr

Toto riešenie je pre naše pouitie nevhodné, lebo Titan nepodporuje ovládaèe pre PHP, celé riešenie je skôr orientované na ve¾ké distribuované enterprise riešenia.


\section{Implementácia}
\noindent V tejto kapitole si priblíime proces 


\subsection{Pouité technológie}

\subsubsection{Laravel framework}
\noindent Laravel Framework je komplexnı vo¾ne šírite¾nı framework. Tento framework je od roku 2015 najpopulárnejší PHP framework. Medzi jeho hlavné vıhody patrí pouitie relatívne novej verzie PHP 5.4, ktorá obsahuje technológie, ktoré v minulosti v PHP chıbali ako menové priestory a anonymné funkcie. Ïalej obsahuje ve¾mi silnı nástroj Eloquent ORM pre objektovo relaèné mapovanie databázy, Blade šablónovací nástroj na rıchlu tvorbu dynamického obsahu.

Komplexita Frameworku Laravel je však aj jeho hlavnou nevıhodou, nie je vhodnı na menšie projekty. V rıchlosti patrí medzi priemer PHP frameworkov. 


\subsubsection{NeoEloquent OGM}
\noindent NeoEloquent OGM je vo¾ne šírite¾ná kninica, ktorá umoòuje vyuíva grafovú databázu neo4j spolu s existujúcim dátovım modelom vo frameworku Laravel. Štruktúra NeoEloquent je modelovaná pod¾a natívneho Eloquent Modelu Laravel. Kninica je vydávaná od roku 2014 pod licenciou MIT spoloènosou Vinelab


\subsubsection{Mapbox.js}
\noindent Mapbox.js je kninica na vytváranie projektov s interaktívnymi mapami. Je zaloená na vo¾ne šírite¾nej kninici Leaflet vyvíjanou Vladimírom Agafonkinom, rozširuje túto kninicu o funkcie ako automatické zoskupovanie bodov do skupín a poskytuje preh¾adnú dokumentáciu. My pouívame verziu zdarma, ktorá je obmedzená na 50000 zobrazení mapy na mesiac. 

Túto kninicu postupne nahrádza Mapbox-gl.js vyvíjaná tou istou firmou, ktorá vyuíva technológiu WebGL na lepšiu akceleráciu vykres¾ovania, no v èase zaèiatku projektu táto kninica ešte nepodporovala vyššie spomenuté zoskupovanie bodov.

\subsubsection{Handlebars.js}
\noindent Handlebars.js je jednoduchá silná open source kninica na prácu z šablónami, vyvíjaná je Yehudom Katzom a komunitou na GitHube od roku 2010 a vydávaná pod licenciou MIT. 

\subsubsection{Rome2Rio Api}
\noindent Rome2Rio je portál ktorı zbiera údaje o cenách dopravy po celom svete a umoòuje vyh¾ada cenu cesty medzi dvomi ¾ubovo¾nımi destináciami. Rome2Rio taktie poskytuje nieko¾ko otvorenıch a platenıch API. My vyuívame dve z nich: Search API a Autocomplete API. Autocomplete API slúi na vyh¾adávanie destinácií z databázy rome2rio a nie je obmedzené na poèet volaní. Search API slúi na vyh¾adávanie trás medzi jednotlivımi destináciami, je potrebné sa identifikova API k¾úèom a je obmedzené na 100 000 volaní za mesiac.



\subsection{Inštalácia a konfigurácia Laravel Framework-u}
\noindent Na inštaláciu frameworku Laravel sme pouili nástroj pre správu PHP balíkov \textit{Composer}. Pomocou tohto nástroja sme nainštalovali balík \textit{laravel/installer} \cite{laravel}, následne sme poitím príkazu \textit{laravel new projekt} vytvorili prieèinok so základnou inštaláciou frameworku.

Jediné nastavanie ktoré bolo po tom potrebné bolo u len nastavenie názvu aplikácie, a databázy, o tom ïalej v sekcii \ref{installneo}.

\subsection{Inštalácia a konfigurácia databázy neo4j}
\label{installneo}
\cite{neoinstall}
\noindent Aby sme mohli nainštalova databázu Neo4j musíme si najprv do systému prida repozitár Neo Technology, potom je nám k dispozícií na inštaláciu balík neo4j. Po inštalácií je nám ihneï dostupné administraèné rozhranie databázy na adrese: \textit{localhost:7474}. Pri prvom prihasení sme vyzvaní na zmenu hesla.

Keïe základná inštalácia frameworku Laravel neobsahuje ovládaè pre databázu neo4j museli sme poui ovládaè integrovanı v balíku NeoEloquent, to sa registráciou poskytovate¾a sluby. Po zaregistrovaní sluby NeoEloquentServiceProvider sa automaticky zaregistruje ovládaè pre databázu a pridajú sa nové monosti pre konfiguráciu databázy. Následne staèí vykona štandardnú konfiguráciu mena hostite¾a, port a prístupovıch údajov.

Na získanie vzdialeného prístupu k administraènému rozhraniu databázy bez otvorenia portu 7474 verejnosti vyuívame SSH tunel. Administraèné rozhranie pouíva okrem portu 7474 ešte port 7687 lebo na komunikáciu s databázou vyuíva technológiu WebScoket.


\begin{algorithm}
	\lstset{
		language=PHP,
		basicstyle=\small\sffamily,
		frame=none,
		numbers=left,
		xleftmargin=5.0ex,
		numberstyle=\tiny,
		stepnumber=1,
		showstringspaces=false,
		keywordstyle=\color{blue}\bfseries
	}
	\lstset{emph={% Adjust any special keywords
			printf%
		},emphstyle={\color[rgb]{1,0,0}\bfseries}%
	}%
	\begin{lstlisting}
	$app->register('Vinelab\NeoEloquent\NeoEloquentServiceProvider');
	...
	'default' => env('DB_CONNECTION', 'neo4j'),
	
	'connections' => [
	'neo4j' => [
	'driver' => 'neo4j',
	'host' => env('DB_HOST', 'neo4j'),
	'port' => env('DB_PORT', 'neo4j'),
	'username' => env('DB_USERNAME', 'neo4j'),
	'password' => env('DB_PASSWORD', 'neo4j'),
	],
	],
	\end{lstlisting}
	\caption{Ukáka algoritmu}
	\label{euclid}
\end{algorithm}




\subsection{OGM}
\label{ogm}
\noindent Keïe framework Laravel natívne obsahuje len ovládaèe pre relaèné databázové ovládaèe a nástroj na objektovo relaèné mapovanie Eloquent.

Pouili sme open source balík NeoEloquent, ktorı obsahuje ovládaè pre databázu Neo4J a zároveò rozširuje dátovı model o prvky grafovej databázy. NeoEloquent umoòuje manipuláciu s vrcholmi aj hranami v Neo4J. Manipulácia s vrcholmi je rovnaká ako s entitami v relaènej databáze, NeoEloquent umoòuje vytvára perzistentné objekty, upravova ich a vyh¾adáva v nich. Pri práca s hranami je mierne odlišná. Najprv treba zadefinova ktorı objekt môe ma aké vzahy, tieto vzahy treba unikátne identifikova ich typom a kardinalitou. Tento vzah vraciame ako návratovú hodnotu funkcie daného objektu. Vrátenı objekt sa správa podobne ako štandardná entitná trieda Eloquent.

V nasledujúcom príklade \ref{codeauth} vidíme implementáciu dvoch rôznych tried. Trieda poívate¾a dedí od triedy NeoEloquent a teda sa stáva naviazanou na vrchol v našej databáze. Názov tejto entity v databáze je spojením menového priestoru v ktorom bol vytvorenı a názvu triedy, take v našom prípade AppUser. Trieda obsahuje verejné funkcie, ktoré vracajú objekty hrán. Objekty hrán dostávame volaním zdedenıch funkcii hasMany, hasOne a belongToMany. Ako prvı argument funkcie berú názov triedy ktorou vzah chceme vráti, ako druhı argument berie typ hrany, pomocou tohto typu je identifikovanı typ hrany v databáze. 

Trieda NeoEloquent funguje vo väèšine prípadov presne ako Eloquent no v jednom prípade sme mali problém z CSRF tokenmi. CSRF token je bezpeènostnı prvok, ktorı ochraòuje webovú stránku pred útokom falšovania poiadaviek z inej adresy. Laravel má tento bezpeènostnı prvok vstavanı v sebe, je to 40 znakovı reazec, ktorı sa generuje kadému pouívate¾ovi pri zobrazení formulára, tento istı reazec sa zároveò uloí do databázy a keï Laravel príjme formulár overí èi sa jeho token nachádza v databáze. Táto funkcionalita však po prejdení na grafovú databázu nefungovala. Pri kadom odoslaní formulára vyhlasovalo nezhodu CSRIF tokenu a v databáze sa neobjavila entita ktorá by tieto tokeny mohla obsahova.  Tento problém sme zatia¾ obišli deaktiváciou tohto bezpeènostného prvku. 

\begin{algorithm}
	\lstset{
		language=PHP,
		basicstyle=\small\sffamily,
		frame=none,
		numbers=left,
		xleftmargin=5.0ex,
		numberstyle=\tiny,
		stepnumber=1,
		showstringspaces=false,
		keywordstyle=\color{blue}\bfseries
	}
	\lstset{emph={% Adjust any special keywords
			printf%
		},emphstyle={\color[rgb]{1,0,0}\bfseries}%
	}%
	\begin{lstlisting}
	namespace App;
	
	class User extends \NeoEloquent implements Authenticatable {
	
	// Jeden pouívate¾ môe ma v ob¾úbenıch viac miest 
	public function follows() {
	return $this->hasMany('App\Place', 'FOLLOWS');
	}
	
	// Jeden pouívate¾ má jedno miesto ako domáce
	public function home() {
	return $this->hasOne('App\Place', 'HOME');
	}
	...
	}
	...
	class Place extends \NeoEloquent {
	// Inverznı vzah - jedno miesto má v ob¾úbenıch viac pouívate¾ov
	public function followers(){
	return $this->belongsToMany('App\User','FOLLOWS');
	}
	...
	}
	\end{lstlisting}
	\caption{Ukáka triedy neoEoquent}
	\label{codeauth}
\end{algorithm}


\subsection{Autentifikácia}
\noindent Jednou zo silnıch stránok Frameworku Laravel je práve autentifikácia. Pre vytvorenie základnej funkcionality registrácie, prihlasovania a obnovenia zabudnutého hesla staèí poui Artisan - konzolu frameworku príkaz (\textit{php artisan make:auth}) , ktorá vytvorí URL cesty, obrazovky, triedu pouívate¾a a triedy obsluhujúce túto funkcionalitu. My sme potrebovali poui vlastnú triedu pouívate¾a, ktorá dedí od nášho balíka NeoEloquent, na implementáciu autentifikácie staèilo neimplementova rozhranie Authenticatable, prida do triedy pouívate¾a pole skrytıch a verejnıch atribútov, a poui charakteristiku 'AuthenticableTrait' a autentifikácia fungovala rovnako ako s relaènou databázou vïaka tomu, e NeoEloquent pokrıva všetky funkcie natívneho Eloquent ORM. 

\begin{algorithm}
	\lstset{
		language=PHP,
		basicstyle=\small\sffamily,
		frame=none,
		numbers=left,
		xleftmargin=5.0ex,
		numberstyle=\tiny,
		stepnumber=1,
		showstringspaces=false,
		keywordstyle=\color{blue}\bfseries
	}
	\lstset{emph={% Adjust any special keywords
			printf%
		},emphstyle={\color[rgb]{1,0,0}\bfseries}%
	}%
	\begin{lstlisting}
	
	namespace App;
	
	use Illuminate\Contracts\Auth\Authenticatable;
	use Illuminate\Auth\Authenticatable as AuthenticableTrait;
	
	class User extends \NeoEloquent implements Authenticatable {
	
	use AuthenticableTrait;
	
	// pole verejnıch atribútov
	protected $fillable = [
	'name', 'email', 'password', 'tspCache'
	];
	
	// pole skrytıch atribútov
	protected $hidden = [
	'password', 'remember_token',
	];
	...
	}
	\end{lstlisting}
	\caption{Ukáka autentifikovate¾nej triedy}
	\label{codeauth}
\end{algorithm}



\subsection{API}
\noindent Keïe sme sa rozhodli vyui javascriptové zobrazovanie dynamického obsahu museli sme vytvori interné API, aby sme mohli javascriptu poskytnú údaje. Na tento úèel sme vytvorili nieko¾ko ciest pomocou routovacieho nástroja frameworku. Router Laravel-u je relatívne jednoduchı, ale silnı nástroj na vytváranie RESTful API. Na naše potreby sme potrebovali vytvori tri REST cesty: \textit{/place}, \textit{/placeapi} a \textit{/tsp}. Prvá je na pridávanie destinácií, druhá na pridávanie, odoberanie ob¾úbenıch a zobrazovanie ob¾úbenıch destinácií, tretia na pridávanie odoberanie a zobrazovanie destinácií na zozname TSP.


\subsection{Rome2rio API}
\noindent Všetky údaje o destináciách a trasách berieme z API Rome2Rio. Pomocou Autocomplete API umoòujeme pouívate¾ovi pridáva destinácie. Pouívate¾ zadáva písmená do autocomplete textového po¾a na stránke toto pole posiela dotazy na Autocomplete API a ono vracia pole objektov s miestami. Tieto objekty obsahujú informácie o type destinácie(obec, mesto, región, štát, letisko,), geografickú polohu, názov v dlhom a krátkom tvare a kanonickı názov. Pouívate¾ si potom vyberie jenu z destinácií a príslušnı objekt sa zašle na náš server. Na unikátnu identifikáciu objektu pouívame kanonickı názov, ktoré je pod¾a dokumentácie unikátnym identifikátorom miesta. 

Ak destináciu ešte nemáme v databáze, pridáme tento objekt do databázy. Toto riešenie nie je úplne ideálne z bezpeènostného h¾adiska, lebo umoòuje zaslanie falošného miesta do našej databázy. AK by útoèník vyrobil objekt s reálnym kanonickım názvom no falošnımi údajmi napr. o zemepisnej šírke, dåke toto miesto by sa potom nesprávne zobrazovalo všetkım pouívate¾om. Na vyriešenie tohto problému by postaèilo urobi ešte jeden dotaz z nášho servera na autocomplete API ktorım by sme si len vypıtali údaje k miestu za pomoci kanonického názvu.

Ïalšie údaje berieme z Rome2Rio Search API. Sú to údaje o monıch trasách a ich cenách. Toto API je obmedzené na poet volaní preto sme na volanie toho API implementovali pamä cache. Vdy keï voláme search API voláme ho na dve miesta ,ktoré u máme uloené v našej databáze ako vrcholy. Tento fakt sme vyuili a vytvorili sme ïalší typ hrany - CACHE. Keïe pri mestách ktoré sú dopravné uzly vystúpila ve¾kos odpovede API a na rádovo 500kb a tento typ dopytu sa nerobí ve¾mi èasto rozhodli sme sa odpoveï servera neuklada priamo do databázy ale v nezmenenej podobe na disk a do databázy uloi len vek cache súboru a referenciu na súbor na disku. Keïe v momentálnej podobe nevyuívame celú odpoveï tohto API mohli by sme zoptimalizova vyuitie miesta na disku tım, e by sme najprv údaje zapracovali a uloili len tie, ktoré vyuívame.

%TODO KIWI.com ANOTHER SOURCES Problémom takejto integrácie Rome2Rio API do našej aplikácie je, e ak by sme chceli bra údaje z inıch zdrojov boli by nutné zmeny v štruktúre ukladania dát aby boli 

\subsection{TSP}
\noindent V aplikácií sa nachádza obrazovka, na ktorej si môe pouívate¾ vybra destinácie, pre ktoré by chcel vyráta trasu optimálnu vzh¾adom na cenu. Táto trasa bude zaèína v domovskej lokácií pouívate¾a, prejde všetkımi vybranımi destináciami práve raz a vráti sa spä do domácej lokácie. Toto je klasickı prípad NP-complete problému pocestného obchodníka. 

Pre jednoduchos a spo¾ahlivos sme naimplementovali prístup rekurzívneho preh¾adania všetkıch monosti trás. Naimplementovali sme rekurzívnu funkciu v PHP, ktorá prejde všetkımi monımi trasami medzi našimi destináciami a vyberie prechod grafom, ktorı je optimálny vzh¾adom na cenu celkovej trasy. Do argumentu naša funkcia berie vıchodzie miesto, zoznam destinácií ktoré ešte nepreh¾adala a domáce miesto do ktorého sa má nakoniec vráti. V kadom vnorení sa zoznam nepreh¾adanıch vrcholov zmenšuje. Vyššie spomenuté argumenty sú perzistentné objekty resp. polia inštancií perzistentnej triedy \textit{Place}.

Keï sa táto funkcia dopytuje na cenu trasy vedúcej z vıchodzieho vrcholu do cie¾ového zavolá ktorá dá dopyt na našu databázu, ak sa táto trasa nenachádza v databáze vypıta si údaje o konkrétnej trase od API Rome2Rio. Keïe kadı dopyt na API trvá cca 200ms prvé volanie pri väèšej trase trvá nieko¾ko násobne dlhšie ako kadé nasledujúce.

Aj po naèítaní všetkıch potrebnıch trás však bolo naše riešenie príliš pomalé, pri siedmych miestach u trvalo rátanie TSP a 7 minút. Toto bolo spôsobené tım, e naša funkcia, ktorá poèíta s vıpoètovou komplexitou \textit{N!} beí na vrstve PHP a pri kadom volaní funkcie invokuje kninicu NeoEloquent a dopytuje sa na hranu medzi dvoma destináciami. Keï funkcia v takomto reime beala videli sme, e proces neo4j konzistentné bral cca 30\% z procesorového èasu. Z tohto dôvodu sme naimplementovali cache na dopyt k databáze a priemernı èas sa zníil na 80 sekúnd. 

Naša implementácia front endu vyaduje dva dopyty na náš server, jeden na zobrazenie mapy a druhı na zobrazenie tabu¾ky s vısledkami, z tohto dôvodu sme pridali ešte jeden level cache na celé volanie funkcie pre rátanie TSP. Taktie sme upravili implementáciu front endu tak, aby sa tieto dva dopyty vykonali vdy synchrónne za sebou. Tımto sme zníili nároky na vıpoètové kapacity nášho serveru. 

Dlhı èas vıpoètu pri dopytovaní sa na databázu pripisujeme tomu, e naše dopyty na databázu boli diskrétne pri kadom vnorení funkcie. Aj keï sme pouívali perzistentné objekty implementácia kadého dopytu NeoEloquent pozostáva z jedného dopytu v jazyku Cypher na databázu toto volanie obsahuje vyh¾adanie zaèiatoèného a koneèného bodu pod¾a id $O(log(n))$ a následne vyh¾adanie hrany $O(1)$. Tento prístup nevyuíva hlavnú vıhodu grafovej databázy, no s pouitím NeoEloquent nie je moné postavi komplexnı dopyt, ktorı by vedel vyrieši TSP za jeden beh. 

Takıto dopyt je v Neo4J moné implementova pomocou dopytovacieho jazyka Cypher príklad takéhoto dopytu môeme vidie na ukáke \ref{cypherTSP}. Aj tento dopyt však iba permutuje všetky riešenia a vráti optimálne a preto v je v reálnom prípade vhodnejšie poui známe algoritmy, v programovej vrstve.
%TODO CYPHER TSP!!!!!!!
\begin{algorithm}
	\lstset{
		language=PHP,
		basicstyle=\small\sffamily,
		frame=none,
		numbers=left,
		xleftmargin=5.0ex,
		numberstyle=\tiny,
		stepnumber=1,
		showstringspaces=false,
		keywordstyle=\color{blue}\bfseries
	}
	\lstset{emph={% Adjust any special keywords
			printf%
		},emphstyle={\color[rgb]{1,0,0}\bfseries}%
	}%
	\begin{lstlisting}
	MATCH (from:Node {name: "Source node" })
	MATCH path = (from)-[:CONNECTED_TO*6]->()
	WHERE ALL(n in nodes(path) WHERE 1 = length(filter(m in nodes(path) WHERE m = n)))
	AND length(nodes(path)) = 7
	RETURN path,
	reduce(distance = 0, edge in relationships(path) | distance + edge.distance)
	AS totalDistance
	ORDER BY totalDistance ASC
	LIMIT 1
	\end{lstlisting}
	\caption{Ukáka riešenia TSP pomocou dopytovacieho jazyka Cypher}
	\label{cypherTSP}
\end{algorithm}



\subsection{Mapa}
\noindent Na vizualizáciu destinácií a trás sme na rôznych miestach a aplikácií pouili javascriptovú kninicu Mapbox.js. Na inicializáciu mapu sme naimplementovali funkciu \ref{coderecommendmap}.

Keïe Mapbox.js rozširuje kninicu Leaflet, všetky funkcie kninice sa volajú z globálneho objektu \textit{L}. Táto funkcia sa zavolá po naèítaní stránky. Keïe sa mapy Mapbox.js sa sahujú z CDN Mapbox musíme najprv aplikáciu identifikova API k¾úèom, ktorı sme si vygenerovali po registrácií. Následne inicializuje samotná mapu volaním funkcie \textit{ L.mapbox.map}. Táto funkcia berie ako prvı parameter id HTML elementu, do ktorého sa má mapa zobrazi, ako druhı parameter berie textovı identifikátor typu mapy, ktorı chceme zobrazi. Po inicializácií sa vytvorí vrstva pre mapu ktorá bude obsahova markery destinácií. Dáta ktoré obsahujú geografickú polohu destinácií sa vyiadajú vo formáte GeoJson z API našej aplikácie. Keïe pri malom priblíení mapy by sa nedali zrete¾ne rozlíši destinácie ktoré sú blízko pri sebe, po naèítaní dát vytvoríme vrstvu clusterov pomocou funkcie \textit{L.MarkerClusterGroup}. Táto vrstva spojí blízke body do clusterov, následne skryje znaèky tıchto bodov a nahradí ich znaèkou clusteru. Na pridanie bodov do clusterov sa iteruje cez všetky body, ktoré sú po naèítaní v mape a kadı sa pridá do vrstvy clusterov. Následne sa vrstva clusterov pridá do objektu mapy.
%TODO ref tech
%TODO screenshoot markercluster ref

Ako zdrojovı formát dát pre všetky mapy v našej aplikácií pouívame štandardnı formát GeoJson. GeoJson je dátová štruktúra zakódovaná do formátu JSON obsahujúca informácie potrebné na vykres¾ovanie kartografickıch velièín. V našej implementácií pouívame nasledovnú štruktúru GeoJson objektu. Hlavnı objekt GeoJson obsahuje typ, u nás \textit{FeatureCollection}, a pole objektov typu \textit{Feature}. Kadı z tıchto objektov obsahuje pole koordinátov, a objekt dodatoènıch atribútov slúiacich na upresnenie vizuálu vykresleného objektu. Spomínané pole koordinátov nám spôsobovalo mierne nedorozumenia, lebo v èíslovanom poli je ako prvı prvok je uloená zemepisná dåka (longitude) a ako druhı zemepisná šírka (latitude) \cite{geojson}, èo je presne opaène ako všetky ostatné API ktoré sme pouívali.


\subsection{Vykres¾ovanie tabuliek}
\noindent Aby sme zlepšili UX stránky rozhodli sme sa na vykres¾ovanie dynamického obsahu vyui namiesto HTML obsahu renderovaného na serveri javascriptovú kninicu na prácu so šablónami a, dynamickı obsah naèítavame z API našej aplikácie vo formáte JSON. Na vykres¾ovanie dynamického obsahu sme zvolili kninicu Handlebars.js. Na príklade \ref{dynamictable} môeme ukáza príklad našej implementácie dynamickej tabu¾ky pre hlavnú tabu¾ku zobrazujúcu destinácie a ich detaily.

Najprv je zadeklarovaná premenná v \textit{template} ktorá bude neskôr obsahova funkciu renderujúcu šablónu. Potom je zadeklarovaná funkcia \textit{refreshPage}, ktorá bude volaná vdy, keï nejaká funkcia spustí event s menom \textit{appRefresh}. Táto funkcia vyuije AJAX API kninice jQuery a stiahne potrebné dáta, potom vyuije funkciu \textit{template}, ktorá do argumentu berie dáta vo forme po¾a objektov a vracia vygenerované HTML ktoré sa následne vkladá na stránku.

V druhej èasti kódu sa najprv zavolá funkcia \textit{Handlebars.compile} do argumentu zoberie šablónu ktorá je uloená v elemente s id \textit{places-template}. Ako návratovú hodnotu vráti funkciu, ktorú uloíme pod menom \textit{template}. Následne sa na event \textit{appRefresh} naviae volanie funkcie \textit{refreshPage} a prvı krát sa spustí tento event.

Naša šablóna \textit{places-template} obsahuje aj aktívne linky a v nasledujúcom bloku je príklad implementácie vymazania miesta z ob¾úbenıch. Na generálny event \textit{click} je naviazanı filtrovanı event, ktorı spustí AJAX dotaz na vymazanie miesta z ob¾úbenıch ak element ktorı event spustil obsahuje triedu \textit{delete} a atribút\textit{data-id}.

\begin{algorithm}
	\lstset{
		language=JavaScript,
		basicstyle=\small\sffamily,
		frame=none,
		numbers=left,
		xleftmargin=5.0ex,
		numberstyle=\tiny,
		stepnumber=1,
		showstringspaces=false,
		keywordstyle=\color{blue}\bfseries
	}
	\lstset{emph={% Adjust any special keywords
			printf%
		},emphstyle={\color[rgb]{1,0,0}\bfseries}%
	}%
	\begin{lstlisting}
	var template; 
	function refreshPage (){
	$.get('/placeapi?type=template', function (data) {
	data = JSON.parse(data);
	home = data.places[0];
	$('#places_body').html(template(data));
	});
	}
	
	$(document).ready(function() {
	
	template = Handlebars.compile($("#places-template").html());
	}).on('appRefresh',refreshPage).trigger('appRefresh');
	
	$(document).on('click', '.delete[data-id]', function (e) {
	e.preventDefault();
	$.ajax({ url: '/placeapi/' + $(this).data('id'), type: 'POST',
	success: function () {
	$(document).trigger('appRefresh');
	}
	});
	});
	\end{lstlisting}
	\caption{Implementácia dynamickej tabu¾ky}
	\label{dynamictable}
\end{algorithm}




