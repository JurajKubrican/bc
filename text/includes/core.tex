\section{Analıza problému}
\noindent V tejto kapitole si predstavíme koncept grafovıch databáz a opíšeme, ako natívne riešia vzahy medzi dátami. Ïalej si priblíime, ako riešia relaèné vzahy a dokumentové databázy. Následne si predstavíme troch najpopulárnejších predstavite¾ov grafovıch databáz a vyberieme z nich jednu, s ktorou budeme ïalej pracova. Nakoniec si predstavíme syntax dopytovacieho jazyka vybranej databázy.

\subsection{Grafové databázy}
\noindent Modelovanie grafovej databázy prirodzene zapadá do spôsobu, akım bene abstrahujeme problémy pri vıvoji softvéru. Pri návrhu  softvéru objekty opisujeme obdånikmi alebo kruhmi a súvislosti medzi nimi šípkami èi èiarami. Moderné grafové databázy sú, viac ako akáko¾vek iná databázová technológia, vhodné na takúto reprezentáciu, lebo to, èo namodelujeme na papier vieme priamo implementova v našej grafovej databáze \cite[25--27]{graphDBs}.

Grafové databázy vyuívajú model, ktorı pozostáva z hrán, vrcholov, atribútov a znaèiek. Vrcholy obsahujú atribúty a sú oznaèené jednou alebo viacerımi znaèkami. Tieto znaèky zoskupujú vrcholy, ktoré zastávajú rovnakú rolu v rámci aplikácie. Hrany v grafovıch databázach spájajú vrcholy a budujú štruktúru grafu. Hrana grafu má vdy smer, názov, zaèiatoènı vrchol a koncovı vrchol. To, e hrany musia ma smer a názov pridáva sémantickú preh¾adnos do grafu. Ak zvolíme správne názov, vieme rıchlo identifikova štruktúru grafu a vıznam vzahov. Hrany môu rovnako, ako vrcholy obsahova aj atribúty. Atribúty v hranách môu by pouité na pridanie kvalitatívnych dát (napr. váha, vzdialenos) ku vzahom. Tieto dáta sa potom môu poui pri preh¾adávaní grafu.

Natívne grafové databázy pouívajú bezindexovú pri¾ahlos. To znamená, e prepojenia sa riešia pomocou ukazovate¾ov a nie cudzích k¾úèov, ako v relaènıch databázach. Absencia cudzích k¾úèov v praxi znamená, e pri preh¾adávaní vzahov je vıpoètová zloitos preh¾adania jednej hrany $O(1)$. Táto rıchlos je dosiahnutá tak, e všetky hrany sú uloené s priamymi ukazovate¾mi na vrcholy, ktorıch vzah reprezentujú. Taktie, vo vrcholoch sú uloené priame ukazovatele na všetky hrany vychádzajúce z nich a mieriace do dotyèného vrcholu. Takáto štruktúra poskytuje u spomínanú vıpoètovú zloitos $O(1)$ v oboch smeroch hrany, take nielen v smere zo zaèiatoèného bodu do koncového, ale aj opaènım smerom\cite[149--158]{graphDBs}. Pri relaènej databáze by toto muselo by riešené reverznım vyh¾adávaním v cudzích k¾úèoch.

\subsection{Vzahy v relaènıch databázach}
\label{relational} 
\noindent Pod¾a E. F. Codda z roku 1970 je relaèná databáza taká, v ktorej sú údaje uloené pod¾a relaèného databázového modelu. Relaènı model je zaloenı na matematickom aparáte relaènıch mnoín predikátovej logiky. Databázová relácia sa od matematickej líši v tom, e vyuíva pomocnı aparát nazıvanı schéma. V databáze, schéma definuje názov relácie (tabu¾ky), ko¾ko obsahuje ståpcov a ich dátovı typ\cite{codd}.

Vıvojári databáz sa u desaroèia snaia relaèné databázy prispôsobi na to, aby boli schopné efektívne pracova s husto prepojenımi sadami dát. Keïe štruktúra relaènıch databáz bola pôvodne navrhnutá na ukladanie formulárov a tabu¾kovıch štruktúr, vznikajú problémy pri snahe zahrnú vzahy, ktoré sa vyskytujú v dátach v reálnom svete \cite[11--12]{graphDBs}.

Vzahy sa v relaènıch databázach vyskytujú iba vo fáze návrhu. V reálnej implementácii tieto vzahy nahrádzajú spájacie tabu¾ky a cudzie k¾úèe. Tımto prístupom rıchlo narastá komplexnos riešenia a zniuje sa preh¾adnos dátového modelu. Pridáva sa záa na databázu vznikom ve¾kıch spájacích tabuliek a ståpcov s cudzími k¾úèmi, ktoré môu by riedko zaplnené, ale zaberajú priestor na disku\cite[11--12]{graphDBs}.

Kadé prepojenie pri preh¾adávaní vzahov v relaènej databáze pridáva vıpoètovú zloitos. V kadej ïalšej prepojenej tabu¾ke treba vyh¾ada záznam s poadovanım k¾úèom so zloitosou $O(log(n))$. Pouívané relaèné databázové systémy riešia tento vıpoètovı problém pouitím indexov a inımi  optimalizáciami. Ale pokia¾ je dátová sada štruktúrovaná s ve¾kım mnostvom vzahov, systém sa spravidla spomalí.

Na obrázku è.\ref{relational-relationships} vidíme prístup riešenia vzahov v relaènej databáze.

\begin{figure}[H]
	\centering
	\includegraphics[width=8cm]{img/relational-relationships.png}
	\caption{Ukáka riešenia vzahov v relaènej databáze \cite[12]{graphDBs}}
	\label{relational-relationships}
\end{figure}


\subsection{Vzahy v dokumentovıch databázach}
\noindent Dokumentové databázy patria rovnako, ako grafové do kategórie NoSQL databáz. V dokumentovej databáze sa údaje ukladajú, ako štruktúrované objekty, ktoré sú adresované pomocou unikátnych k¾úèov. Sémanticky vieme dokumenty rozlíši do kolekcií pod¾a ich vıznamu v databáze. Štruktúra grafovej databázy je primárne urèená na dopyt pod¾a k¾úèa a neposkytuje vıhodu pri preh¾adávaní cez vzahy oproti relaènım databázam. Rôzne implementácie dokumentovıch databáz implementujú odlišné prístupy k riešeniu vzahov.

Benı spôsob na pridanie vzahov do štruktúry dokumentovej databázy je pridanie atribútu do dokumentu, ktorı bude odkazova na k¾úè a kolekciu dokumentu, s ktorım chceme vytvori vzah. Tımto spôsobom vieme poui koncept cudzích k¾úèov z relaènıch databáz. Tento prístup sa však stretáva s rovnakımi problémami v rıchlosti, ako pri relaènıch databázach s pridanou zloitosou v tom, e tento dopyt musíme èasto implementova na strane aplikácie.

Na obrázku è.\ref{document-relationships} vidíme príklad prístupu implementácie vzahov v dokumentovej databáze.

\begin{figure}[H]
	\centering
	\includegraphics[width=8cm]{img/document-relationships.png}
	\caption{Ukáka riešenia vzahov v dokumentovej databáze \cite[15]{graphDBs}}
	\label{document-relationships}
\end{figure}

\subsection{Vıber grafovej databázy} 
\noindent Vybrali sme si troch najpopulárnejších predstavite¾ov grafovıch databáz pod¾a rebríèka DB-Engines.com. V nasledujúcej èasti v skratke priblíime históriu kadej grafovej databázy, ich vıhody a nevıhody.

\subsubsection{Neo4J}
\noindent Prvá verzia Neo4J bola vydaná v roku 2007. Od vtedy sa stala dlhodobo najpouívanejšou grafovou databázou. Je vyvíjaná Neo Technology, Inc. Neo4j je ponúkaná v dvoch variantoch: Neo4j Community a Neo4j Enterprise. Neo4j Community je open source (GPLv3) grafová databáza obsahujúca všetky základné funkcie. Ïalej budeme spomína len túto verziu. A Neo4j Enterprise edícia, ktorá má rozšírené funkcie, ako zdie¾anie vyrovnávacej pamäte, rozšírené monitorovanie a zálohovanie za behu\cite{dbrank} \cite{neo-product}\\.


\noindent \textbf{Medzi hlavné vıhody Neo4J patria:}
\begin{itemize}
	\item Pod¾a rebríèka db-rank\cite{dbrank}, je dlhodobo najpopulárnejšo	u grafovou databázou. To znamená, e máme k dispozícii dobrú dokumentáciu, podporu na internete a väèšiu podporu pre integráciu s populárnymi frameworkami.
	\item Dopytovací jazyk Cypher, ktorı táto databáza podporuje. Tento jazyk je vizuálne zrozumite¾nı a navrhnutı primárne pre prácu z grafovou databázou. Ïalej sa mu venujeme v kapitole \ref{chap-cypher}.
	
\end{itemize}

\noindent \textbf{Nevıhodami Neo4J sú:}
\begin{itemize}
	\item Nišia rıchlos oproti OrientDB.
	\item Podporuje iba grafovı model ukladania údajov.
\end{itemize}

\subsubsection{OrientDB}
\noindent OrientDB je vyvíjané od roku 2010 firmou OrientDB LTD. Databáza OrientDB rıchlo nabrala na popularite a v roku 2015 sa dostala na druhé miesto v rebríèku DB-engines. OrientDB sa rovnako, ako Neo4j distribuuje v dvoch edíciách: Community - open source (Apache Licence 2.0) so základnımi funkciami a Enterprise edícia s podporou migrácie, a synchronizácie na Neo4J, a pridanımi analytickımi nástrojmi \cite{dbrank} \cite{orientdb-product}.\\

\noindent \textbf{Medzi hlavné vıhody OrientDB patrí:}
\begin{itemize}
	\item Podporuje okrem grafového modelu ukladania dát aj dokumentové úloisko typu k¾úè-hodnota.
	\item Pod¾a nezávislıch testov \cite{dbspeed} je v niektorıch testoch a desakrát rıchlejšie ako Neo4J.
\end{itemize}

\noindent \textbf{Nevıhodami OrientDB sú:}
\begin{itemize}
	\item Má menšiu podporu pre populárne frameworky. Konkrétne OGM pre Laravel nepodporuje ukladanie a èítanie atribútov z hrán.
	\item Menej intuitívny dopytovací jazyk v kontexte grafovıch databáz.
\end{itemize}


\subsubsection{Titan} 
\noindent Projekt Titan bol od roku 2012 vyvíjanı skupinou ThinkAurelius. Avšak v roku 2017 bol odkúpenı firmou Datstax a projekt bol zastavenı. Projekt je ïalej udriavanı, ako open source verzia pod menom JanusGraph.\\
Titan bol projekt urèenı na ve¾ké distribuované enterprise riešenia. Nasadzovanı na cloudové platformy ako napr. Apache Hadoop a Apache Spark. Podporuje rôzne distribuované úloné priestory, ako napr. Apache HBase a Oracle Berkeley DB. Ïalej podporuje rôzne vyh¾adávacie prostriedky, ako napr. Elasticsearch a Solr \cite{dbrank} \cite{titan-product}.

\textbf{Medzi hlavné vıhody databázy Titan patrí:}
\begin{itemize}
	\item Podpora rôznych zásuvnıch modulov vyívanıch v enterprise riešeniach.
\end{itemize}

\textbf{Nevıhodami databázy Titan sú:}
\begin{itemize}
	\item Ukonèenie vıvoja po akvizícii firmou DataStax.
	\item Jej urèenie na ve¾ké distribuované systémy.
\end{itemize}

%TODO bleh nadpis
\subsubsection{Vyhodnotenie}
\noindent V procese vıberu databázy sme prihliadali na rôzne faktory. Posudzovali sme hlavne kompatibilitu, jednoduchos pouitia a rıchlos. Nakoniec sme sa rozhodli pre Neo4J práve pre jeho rozšírenos a pouitie jazyka Cypher. Aj keï pod¾a nezávislıch testov je OrientDB rıchlejšie ako Neo4J v kontexte porovnávania relaènıch a grafovıch databáz, tento fakt nezohral ve¾kú rolu, lebo obe databázy sú pri navigovaní grafu rıchlejšie ako relaèné.
Databázu Titan sme vylúèili z vıberu z dôvodu ukonèenia jej vıvoja a urèenia primárne na distribuované systémy.

\subsection{Dopytovací jazyk Cypher}
\label{chap-cypher}
\noindent Dopytovací jazyk Cypher bol vyvinutı firmou NeoTechnology pre ich databázu Neo4J a prípadnú štandardizáciu tohoto jazyka v ostatnıch grafovıch databázach. Cypher bol navrhnutı tak, aby sa ¾ahko èítal a chápal. Preto pouíva intuitívnu \textit{"ASCII Art"} notáciu. Cypher pouíva oblé zátvorky na reprezentáciu vrcholov, hranaté zátvorky a pomlèky na reprezentáciu hrán, a znaky väèší, menší na upresnenie smerovania hrany. Medzi hlavné dopytovacie príkazy v Cypher patrí príkaz MATCH. Tımto príkazom podobne ako SELECT v SQL zaèína kadı dopyt. 

V algoritme è.\ref{cypher} vidíme nieko¾ko príkladov dopytov. V prvom príklade vidíme dopyt, ktorı vyh¾adá vrchol n s \textit{id = 42} (\textit{id} nie je atribút vrchola, preto ho musíme získa pomocou funkcie \textit{id()}), prièom z tohoto vrchola vychádzajú (všimnime si smerovanie "ASCII ART šípky" ) hrany so znaèkou VZTAH, ktoré vedú k cie¾ovım vrcholom so znaèkou \textit{znA}. Všimnime si, e v zátvorkách reprezentujúcich vrcholy a hrany priraïujeme premennım \textit{n}, \textit{m} a \textit{r} kolekcie vrcholov a hrán. Keïe je v dopyte \textit{RETURN r, m}, vrátia sa vrcholy v tıchto kolekciách, èie nie pôvodnı vrchol s \textit{id = 42}.

V druhom príklade vidíme dopyt, ktorı zaène z vrcholov, ktorıch atribút \textit{nazov} má hodnotu \textit{názov}. Ïalej vyh¾adá a vráti všetky vrcholy, ktoré sú od neho v grafe vzdialené tri hrany typu \textit{VZTAH} a ich atribút \textit{text} vyhovuje regulárnemu vırazu \textit{/M.*/}.

V poslednom príklade vidíme príkaz, ktorı najprv vyh¾adá vrcholy s atribútom \textit{meno} a hodnotami \textit{Adam} a \textit{Bernard}, a pridá hranu smerujúcu od prvého smerom k druhému. Vytvorená hrana bude ma atribút \textit{vaha} s hodnotou \textit{7}.

\begin{algorithm}
	\lstset{
		language=PHP,
		basicstyle=\small\sffamily,
		frame=none,
		numbers=left,
		xleftmargin=5.0ex,
		numberstyle=\tiny,
		stepnumber=1,
		showstringspaces=false,
		keywordstyle=\color{blue}\bfseries
	}
	\lstset{emph={% Adjust any special keywords
			printf%
		},emphstyle={\color[rgb]{1,0,0}\bfseries}%
	}%
	\begin{lstlisting}
	
1)
MATCH (n)-[r:VZTAH]->(m:znA)
WHERE id(n) = 42 RETURN r, m

2)
MATCH (n:typ)-[r:VZTAH*3]->(m:znB)
WHERE n.nazov = 'názov' AND m.text=~ "M.*" RETURN m

5) 
MATCH (a:typ),(b:znA) WHERE a.meno = 'Adam' AND b.meno = 'Bernard'
CREATE (a)-[r:VZTAH { vaha: 7 }]->(b)
RETURN r
	\end{lstlisting}
	\caption{Príklady dopytov v jazyku Cypher}
	\label{cypher}
\end{algorithm}





\section{Špecifikácia}
\noindent V tejto kapitole najprv struène opíšeme hlavnú funkcionalitu navrhovanej aplikácie, potom zadefinujeme funkcionálne a nefunkcionálne poiadavky na aplikáciu.

Aplikácia, ktorú sme sa rozhodli implementova bude slúi na plánovanie a optimalizáciu trasy cestovate¾a po svete. Bude umoòova pouívate¾ovi sledova ceny cesty z miest, ktoré si  zadá, do destinácií, ktoré si pridá na zoznam ob¾úbenıch destinácií. Ïalej mu bude ukazova ostatnıch pouívate¾ov, ktorí si zvolili rovnaké destinácie a bude vedie pouívate¾ovi odporuèi ïalšie destinácie na základe zhody s ostatnımi pouívate¾mi. 

\subsection{Funkcionálne poiadavky}
\begin{enumerate}
	\item Aplikácia bude umoòova registráciu a prihlásenie pouívate¾a.
	\item Pri registrácií sa budú vyadova prihlasovacie údaje: e-mail a heslo. Okrem toho sa bude vyadova zadanie domovskej destinácie.
	\item Po prihlásení pouívate¾a sa zobrazí obrazovka s mapou, zoznamom ob¾úbenıch destinácií, ktoré chce navštívi a zoznam odporúèanıch destinácií.
	\item Na mape bude vyobrazená pouívate¾ova domovská destinácia a všetky destinácie, ktoré má v zozname ob¾úbenıch.
	\item V zozname ob¾úbenıch budú všetky destinácie, ktoré si pouívate¾ pridal. Zoznam bude vo forme tabu¾ky, ktorej riadok bude obsahova meno destinácie a cenu najlacnejšej trasy z domovskej destinácie do cie¾ovej destinácie. 
	\item Budú sa da zobrazi informácie o všetkıch dostupnıch trasách ku konkrétnej destinácii s ich cenami a spôsobmi dopravy.
	\item V detailoch ob¾úbenej destinácie bude zoznam ostatnıch pouívate¾ov, ktorí danú destináciu majú tie na zozname ob¾úbenıch.
	\item V zozname odporúèanıch destinácií budú destinácie, ktoré majú na zozname ¾udia, s ktorımi má prihlásenı pouívate¾ najviac spoloènıch destinácií.
	\item V aplikácií bude obrazovka, kde si bude pouívate¾ vybera nieko¾ko zo svojich ob¾úbenıch destinácií a nechá si vyráta optimálnu trasu z domovskej destinácie cez všetky zvolené miesta a potom spa (TSP).
\end{enumerate}	



\subsection{Nefunkcionálne poiadavky}
\begin{enumerate}
	\item Systém bude zrealizovanı na webovej platforme.
	\item Aplikácia bude vyuíva natívnu grafovú databázu.
	\item Aplikácia bude kompatibilná s poslednımi verziami webovıch prehliadaèov  Google Chrome, Mozilla Firefox, Microsoft Edge.
	\item Uívate¾ské rozhranie systému musí by plne funkèné aj na mobilnıch telefónoch s operaènım systémom Android a IOS.
	\item Aplikácia bude implementovaná s pouitím jazyka PHP a PHP frameworku.
	\item Systém bude nasadenı na virtuálnom serveri s operaènım systémom Ubuntu 16.04.2 LTS poskytnutom Ústavom informatiky a matematiky FEI STU.
\end{enumerate}


\section{Návrh}
\noindent V tejto kapitole si priblíime proces návrhu našej aplikácie. Popíšeme prípady pouitia, ktoré pre našu aplikáciu chceme pokry. Ïalej si priblíime návrh štruktúry databázy a nakoniec si priblíime štruktúru samotnej aplikácie, ktorú budeme implementova.

\subsection{Prípady pouitia}
\noindent Prípady pouitia popisujú interakcie medzi aplikáciou a pouívate¾om. Popisujú roly, ktoré rôzni aktéri majú v tıchto interakciách. 

\begin{enumerate}
	\item	V prvom prípade pouitia (obrázok è.\ref{usecase-login}) si bude môc neprihlásenı pouívate¾ prezera mapu a zoznam najpopulárnejších destinácií v našej aplikácii. Ïalej sa môe prihlási, zaregistrova a poiada o obnovu hesla.
	\begin{figure}[H]
		\centering
		\includegraphics[width=10cm]{uml/usecase-login.pdf}
		\caption{Prípad pouitia - Registrácia, autentifikácia, obnova hesla a prezeranie informácií}
		\label{usecase-login}
	\end{figure}
	
	\item	V druhom prípade pouitia (obrázok è.\ref{usecase-settings}) opisujeme nastavenia. Pouívate¾ si bude môc vyh¾ada destináciu a zvoli si ju, ako svoju domovskú destináciu alebo si zmeni heslo.
	\begin{figure}[H]
		\centering
		\includegraphics[width=10cm]{uml/usecase-settings.pdf}
		\caption{Prípad pouitia - Nastavenia}
		\label{usecase-settings}
	\end{figure}
	
	\item Tretí prípad pouitia (obrázok è.\ref{usecase-dash}) opisuje akcie, ktoré bude môc pouívate¾ vykonáva na hlavnej stránke. Bude môc vyh¾adáva destinácie a pridáva si ich do ob¾úbenıch. Destinácie, ktoré má v ob¾úbenıch bude môc maza a zobrazi detaily trasy, ktorá k destinácii vedie. Ïalej si bude môc prezera ostatnıch pouívate¾ov, ktorí majú rovnaké miesto v ob¾úbenıch a prejs na zoznam ob¾úbenıch destinácií jedného z tıchto pouívate¾ov.
	\begin{figure}[H]
		\centering
		\includegraphics[width=10cm]{uml/usecase-dash.pdf}
		\caption{Prípad pouitia - Dashboard}
		\label{usecase-dash}
	\end{figure}
	
	\item Poslednı prípad pouitia (obrázok è.\ref{usecase-tsp}) popisuje obrazovku TSP. Na tejto obrazovke bude môc pouívate¾ prezera svoju mapu optimálnej cestovate¾skej trasy, pridáva a odobera z trasy destinácie zo zoznamu ob¾úbenıch.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=10cm]{uml/usecase-tsp.pdf}
		\caption{Prípad pouitia - TSP}
		\label{usecase-tsp}
	\end{figure}
\end{enumerate}



\subsection{Štruktúra databázy}
\label{db-struct}
\noindent V našej databáze sa budú nachádza dve hlavné entity: entita pouívate¾a \textit{appUser} a entita destinácie \textit{appPlace}. Entita pouívate¾a bude obsahova iba základné atribúty, ako meno a atribúty potrebné pre autentifikáciu pouívate¾a, èie email a heslo. 
Entita destinácie bude obsahova atribúty potrebné na identifikáciu tejto destinácie: unikátny názov a krátky názov vhodnı na zobrazovanie, a atribúty potrebné na lokalizáciu destinácie: zemepisná šírka a zemepisná dåka. 

Ïalej bude naša databáza obsahova hrany: trasa \textit{ROUTES}, ob¾úbené \textit{FOLLOWS} a zoznam pre optimalizáciu trasy \textit{TSP}.
Hrana \textit{ROUTES} bude vdy vies od jedného miesta k druhému. Bude reprezentova zoznam trás, ktoré budú vies od jednej destinácie k druhej. Bude obsahova atribút \textit{minPrice} hovoriaci o cene najlacnejšej trasy medzi spomínanımi destináciami a atribút \textit{routes} obsahujúci serializované detaily všetkıch trás.
Hrany \textit{FOLLOWS} a \textit{TSP} budú vdy smerova od pouívate¾a k destinácii a nebudú obsahova iadne atribúty.

Na obrázku è. \ref{database-diagram} vidíme UML diagram štruktúry našej databázy. 

\begin{figure}[H]
	\centering
	\makebox[\textwidth]{\includegraphics[width=14cm]{uml/database.pdf}} 
	\caption{Štruktúra databázy}
	\label{database-diagram}
\end{figure}

Na obrázku è. \ref{example-simple-data} vidíme reprezentáciu dát uloenıch v našej databáze. Pouívate¾ \textit{user 3} má ako domácu destináciu (HOME) nastavené mesto \textit{Bratislava}. V ob¾úbenıch destináciách (FOLLOWS) má mestá: \textit{Praha}, \textit{Košice} a \textit{Budapeš}. Systém pridal hranu \textit{ROUTES} smerom od domácej destinácie pouívate¾a k cie¾ovım destináciam. Pouívate¾ má tie pridané mestá \textit{Budapeš} a \textit{Košice} na zozname optimalizácie, take sme pridali hranu \textit{TSP}.
\begin{figure}[H]
	\centering
	\makebox[\textwidth]{\includegraphics[width=15cm]{img/example-simple-data.png}} 
	\caption{Príklad dát v databáze}
	\label{example-simple-data}
\end{figure}

\subsection{Štruktúra aplikácie}
\noindent Aplikácia bude implementovaná pod¾a vıvojového vzoru MVC. Bude obsahova dve modelové triedy. Jednu pre pouívate¾ov a jednu pre destinácie. Èas kontroléra bude obsahova tri triedy. Kadá trieda bude obsluhova dopyty jednej podstránky aplikácie. Podstránky sú nasledovné: domovská obrazovka, obrazovka nastavení, a obrazovka pre optimalizáciu trasy. 
Zobrazovanie dynamického obsahu bude implementované pomocou JavaScript šablón a kninice na zobrazenie máp. Dáta na zobrazenie budú poskytované pomocou API našej aplikácie.

\section{Implementácia}
\noindent V tejto kapitole si priblíime proces implementácie aplikácie. Najprv si opíšeme niektoré z pouitıch technológií, následne opíšeme proces inštalácie a konfigurácie frameworku Laravel, a databázy Neo4J. Ïalej opíšeme proces našej implementácie aplikácie s pomocou NeoEloquent OGM a pomocou Neo4J PHP Client. Ïalej opíšeme postup našej implementácie optimalizácie trasy. Potom opíšeme implementáciu získavania informácií z API Rome2Rio a našu implementáciu pouívate¾ského rozhrania pomocou Mapbox.js a Handlebars.js. Nakoniec si predstavíme pouívate¾ské rozhranie našej aplikácie.

\subsection{Pouité technológie}
\noindent v tejto kapitole si priblíime niektoré z technológií, ktoré sme vyuili na implementáciu našej aplikácie. V skratke opíšeme, na èo konkrétna technológia slúi, jej históriu a licenciu, pod ktorou je vydávaná.

\subsubsection{Laravel framework}
\noindent Laravel je open source framework pre aplikácie v jazyku PHP. Je od roku 2011 vyvíjanı Taylorom Otwellom, ako framework urèenı na stavbu webovıch aplikácií s vıvojovım vzorom MVC. Niektoré funkcie sú implementované, ako zásuvné moduly, ktoré sa inštalujú pomocou vlastného správcu závislostí. Laravel je orientovanı na to, aby vıvoj v òom bol syntakticky, èo najpreh¾adnejší a najjednoduchší. Toto je jeden z dôvodov, preèo patrí od roku 2015 k najpopulárnejším PHP frameworkom.
Kód frameworku je vo¾ne dostupnı pod licenciou MIT.

\subsubsection{NeoEloquent OGM}
\noindent NeoEloquent OGM je vo¾ne šírite¾ná kninica, ktorá umoòuje vyuíva grafovú databázu Neo4J spolu s existujúcim dátovım modelom vo frameworku Laravel. Štruktúra NeoEloquentu je modelovaná pod¾a natívneho Eloquent Modelu Laravel. Kninica je vydávaná od roku 2014 pod licenciou MIT spoloènosou Vinelab.

\subsubsection{GraphAware Neo4j PHP Client}
\noindent Neo4j PHP Client je klientská kninica pre databázu Neo4J. Na rozdiel od OGM je táto kninica schopná vykonáva programátorsky zadané dopyty. Poskytuje tım pádom prístup k plnému rozsahu Cypher API databázy Neo4j. Kninica je vyvíjaná partnerskou firmou Neo Technology a firmou GraphAware od roku 2014. Je taktie vydávaná pod licenciou MIT.

\subsubsection{Mapbox.js}
\noindent Mapbox.js je kninica na vytváranie projektov s interaktívnymi mapami. Je zaloená na vo¾ne šírite¾nej kninici Leaflet vyvíjanou Vladimírom Agafonkinom. Rozširuje túto kninicu o funkcie, ako automatické zoskupovanie bodov do skupín a poskytuje preh¾adnú dokumentáciu. Kninica samotná je vo¾ne šírite¾ná pod BSD licenciou. Avšak obrázky s mapami sú poskytované firmou Mapbox a v zadarmo dostupnej verzii je kninica obmedzená na pädesiattisíc zobrazení na mesiac. 

Túto kninicu postupne nahrádza Mapbox-gl.js vyvíjaná tou istou firmou, ktorá vyuíva technológiu WebGL na lepšiu akceleráciu vykres¾ovania vektorovıch máp. Ale v èase zaèiatku projektu táto kninica ešte nepodporovala vyššie spomenuté zoskupovanie bodov.

\subsubsection{Handlebars.js}
\noindent Handlebars.js je jednoduchá silná open source kninica na prácu so šablónami. Vyvíjaná je Yehudom Katzom a komunitou na GitHube od roku 2010 a vydávaná pod licenciou MIT. 

\subsubsection{Rome2Rio Api}
\noindent Rome2Rio je portál, ktorı zbiera údaje o cenách dopravy po celom svete a umoòuje vyh¾adáva cenu cesty medzi dvoma ¾ubovo¾nımi destináciami. Rome2Rio taktie poskytuje nieko¾ko otvorenıch a platenıch API. My vyuívame dve z nich: Search API a Autocomplete API. Autocomplete API slúi na vyh¾adávanie destinácií z databázy Rome2Rio a nie je obmedzené na poèet volaní. Search API slúi na vyh¾adávanie trás medzi jednotlivımi destináciami, prièom je potrebné sa identifikova API k¾úèom a je obmedzené na 100 000 volaní za mesiac.



\subsection{Inštalácia a konfigurácia Laravel Frameworku}
\noindent Na inštaláciu frameworku Laravel sme pouili nástroj pre správu PHP balíkov \textit{Composer}. Pomocou tohoto nástroja sme nainštalovali balík \textit{laravel/installer} \cite{laravel} a následne sme pouitím príkazu \textit{laravel new projekt} vytvorili prieèinok so základnou inštaláciou frameworku.

Jediné nastavanie, ktoré bolo potom potrebné, bolo u len nastavenie názvu aplikácie a databázy. O tom ïalej v sekcii \ref{installneo}.


\subsection{Inštalácia a konfigurácia databázy Neo4J}
\label{installneo}
\noindent Aby sme mohli nainštalova databázu Neo4j, musíme si najprv do systému prida repozitár Neo Technology. Potom je nám k dispozícii na inštaláciu balík Neo4J. Po inštalácii je nám ihneï dostupné administraèné rozhranie databázy na adrese: \textit{localhost:7474}. Pri prvom prihlásení sme vyzvaní na zmenu hesla.

Keïe základná inštalácia frameworku Laravel neobsahuje ovládaè pre databázu Neo4J, museli sme poui ovládaè integrovanı v balíku NeoEloquent a to pomocou registrácie poskytovate¾a sluby. Po zaregistrovaní sluby NeoEloquentServiceProvider sa automaticky zaregistruje ovládaè pre databázu a pridajú sa nové monosti pre konfiguráciu databázy. Následne staèí vykona štandardnú konfiguráciu mena hostite¾a, portu a prístupovıch údajov.

Na získanie vzdialeného prístupu k administraènému rozhraniu databázy bez otvorenia portu 7474 verejnosti, vyuívame SSH tunel. Administraèné rozhranie pouíva okrem portu 7474 ešte port 7687, lebo na komunikáciu s databázou vyuíva technológiu WebSocket.

% TODO READ  THIS be4 seding to Z!!!
\subsection{Implementácia OGM}
\label{ogm}
\noindent Keïe framework Laravel natívne obsahuje len ovládaèe pre relaèné databázy a nástroj na objektovo relaèné mapovanie Eloquent, pouili sme open source kninicu NeoEloquent, ktorá obsahuje ovládaè pre databázu Neo4J, a zároveò rozširuje dátovı model o prvky grafovej databázy. NeoEloquent umoòuje manipuláciu s vrcholmi aj hranami v Neo4J. Manipulácia s vrcholmi je rovnaká, ako s entitami v relaènej databáze. NeoEloquent ïalej umoòuje vytvára perzistentné objekty, upravova ich a vyh¾adáva v nich. Práca s hranami je mierne odlišná. Najprv treba zadefinova, ktorı objekt môe ma, aké vzahy. Tieto vzahy treba jednoznaène identifikova ich znaèkou a kardinalitou. Tento vzah vraciame, ako návratovú hodnotu funkcie daného objektu. Vrátenı objekt sa správa podobne, ako štandardná entitná trieda Eloquent. 

Kninicu sme nainštalovali pomocou správcu balíkov \textit{composer} pomocou príkazu \textit{composer require vinelab/neoeloquent}.

V nasledujúcom príklade \ref{codeauth} vidíme implementáciu dvoch rôznych entitnıch tried. Trieda pouívate¾a dedí od triedy NeoEloquent, a teda sa stáva naviazanou na vrchol v našej databáze. Názov tejto entity v databáze je spojením menného priestoru, v ktorom bol vytvorenı a názvu triedy, take v našom prípade AppUser. Trieda obsahuje verejné funkcie, ktoré vracajú objekty hrán. Objekty hrán dostávame volaním zdedenıch funkcií hasMany, hasOne a belongToMany. Ako prvı argument funkcie berú názov triedy, ktorej vzah chceme vráti, a ako druhı argument berie typ hrany. Pomocou tohoto typu je identifikovaná znaèka hrany v databáze. 

Po spustení aplikácie a zadaní prvıch dát sa v databáze vytvorili vrcholy a hrany pod¾a modelu, ktorı sme si zadefinovali v kapitole \ref{db-struct}. Vizualizáciu dát môeme vidie na obrázku è.\ref{example-simple-data}.

Trieda NeoEloquent funguje vo väèšine prípadov presne ako Eloquent. Avšak v jednom prípade sme mali problém z CSRF tokenmi. CSRF token je bezpeènostnı prvok, ktorı ochraòuje webovú stránku pred útokom falšovania poiadaviek z inej adresy. Laravel má tento bezpeènostnı prvok vstavanı v sebe. Je to 40-znakovı reazec, ktorı sa generuje kadému pouívate¾ovi pri zobrazení formulára. Tento istı reazec sa zároveò uloí do databázy, a keï Laravel príjme formulár, overí èi sa jeho token nachádza v databáze. Táto funkcionalita však po prejdení na grafovú databázu nefungovala. Pri kadom odoslaní formulára vyhlasovalo nezhodu CSRF tokenu a v databáze sa neobjavila entita, ktorá by tieto tokeny mohla obsahova. Tento problém sme zatia¾ obišli deaktiváciou tohoto bezpeènostného prvku. 

Ïalší problém, na ktorı sme narazili poèas implementácie, bol problém kompatibility kninice NeoEloquent verzie 1.4 s databázou Neo4J vo verzii 5.2. Pri ukladaní nového vrcholu vdy nastala chyba. Bolo potrebné zníi verziu databázy.

\begin{algorithm}[H]
	\lstset{
		language=PHP,
		basicstyle=\small\sffamily,
		frame=none,
		numbers=left,
		xleftmargin=5.0ex,
		numberstyle=\tiny,
		stepnumber=1,
		showstringspaces=false,
		keywordstyle=\color{blue}\bfseries
	}
	\lstset{emph={% Adjust any special keywords
			printf%
		},emphstyle={\color[rgb]{1,0,0}\bfseries}%
	}%
	\begin{lstlisting}
namespace App;

class User extends \NeoEloquent implements Authenticatable {
	
	// Jeden pouívate¾ môe ma v ob¾úbenıch viac miest 
	public function follows() {
		return $this->hasMany('App\Place', 'FOLLOWS');
	}
	
	// Jeden pouívate¾ má jedno miesto ako domov
	public function home() {
		return $this->hasOne('App\Place', 'HOME');
	}
	...
}

...
class Place extends \NeoEloquent {
	// Inverznı vzah - jedno miesto má v ob¾úbenıch viac
	// pouívate¾ov
	public function followers(){
		return $this->belongsToMany('App\User','FOLLOWS');
	}
	...
}
	\end{lstlisting}
	\caption{Ukáka triedy NeoEloquent}
	\label{codeNeoEloquent}
\end{algorithm}


\subsection{Autentifikácia}
\noindent Jednou zo silnıch stránok frameworku Laravel je práve autentifikácia. Pre vytvorenie základnej funkcionality registrácie, prihlasovania a obnovenia zabudnutého hesla staèí poui Artisan - v konzole frameworku príkaz \textit{php artisan make:auth}, ktorá vytvorí URL cesty, obrazovky, triedu pouívate¾a a triedy obsluhujúce túto funkcionalitu. My sme potrebovali poui vlastnú triedu pouívate¾a, ktorá dedí od nášho balíka NeoEloquent. Na implementáciu autentifikácie staèilo implementova rozhranie Authenticatable, prida do triedy pouívate¾a, pole skrytıch a verejnıch atribútov, a poui charakteristiku 'AuthenticableTrait'. A autentifikácia fungovala rovnako, ako s relaènou databázou vïaka tomu, e NeoEloquent implementuje podobnú funkcionalitu, ako natívne ORM Eloquent. 

\begin{algorithm} [H]
	\lstset{
		language=PHP,
		basicstyle=\small\sffamily,
		frame=none,
		numbers=left,
		xleftmargin=5.0ex,
		numberstyle=\tiny,
		stepnumber=1,
		showstringspaces=false,
		keywordstyle=\color{blue}\bfseries
	}
	\lstset{emph={% Adjust any special keywords
			printf%
		},emphstyle={\color[rgb]{1,0,0}\bfseries}%
	}%
	\begin{lstlisting}
	
namespace App;

use Illuminate\Contracts\Auth\Authenticatable;
use Illuminate\Auth\Authenticatable as AuthenticableTrait;

class User extends \NeoEloquent implements Authenticatable {
	
	use AuthenticableTrait;
	
	// pole verejnıch atribútov
	protected $fillable = [
		'name', 'email', 'password', 'tspCache'
	];
	
	// pole skrytıch atribútov
	protected $hidden = [
		'password', 'remember_token',
	];
	...
}
	\end{lstlisting}
	\caption{Ukáka autentifikovate¾nej triedy}
	\label{codeauth}
\end{algorithm}



\subsection{Databázové dopyty pomocou OGM}
\label{app-ogm}

API pre získanie dát na zobrazenie zoznamu ob¾úbenıch destinácií sme v prvej verzii implementovali pomocou OGM. Na príklade algoritmu è.\ref{pseudo-neoeloquent} vidíme pseudokód tohoto prístupu. Najprv naša PHP funkcia urobila dopyt na všetky miesta, ktoré má pouívate¾ v ob¾úbenıch. Potom v cykle prešla všetky vısledky a pre kadú destináciu poslala dopyt na trasu medzi domovskou destináciou a touto destináciou. Ïalej poslala dopyt na získanie všetkıch pouívate¾ov, ktorí majú destináciu tie v ob¾úbenıch. 

Pri testovaní rıchlosti sme zistili, e pri takomto prístupe priemerná latencia nášho API vzrástla a na 1,857
sekundy pri 200 polokách na zozname. Tento nárast latencie pripisujeme réii, ktorá si vyaduje diskrétne volanie funkcií OGM v kadom cykle. Ïalej sa testovaniu rıchlosti venujeme v kapitole \ref{speedtest}.

\begin{algorithm} [H]
	\lstset{
		language=PHP,
		basicstyle=\small\sffamily,
		frame=none,
		numbers=left,
		xleftmargin=5.0ex,
		numberstyle=\tiny,
		stepnumber=1,
		showstringspaces=false,
		keywordstyle=\color{blue}\bfseries
	}
	\lstset{emph={% Adjust any special keywords
			printf%
		},emphstyle={\color[rgb]{1,0,0}\bfseries}%
	}%
	\begin{lstlisting}
pouívate¾ = dopytPouívate¾OGM()
destinácie = pouívate¾->dopytOblubeneOGM()
domov = pouívate¾->dopytDomovOGM()

vısledok = []
FOR kadá destinácia z destinácie
	trasa = domov->dopytTrasaOGM(destinácia)
	¾udia = destinácia->dopytLudiaOGM()
	
	vısledok << destinácia, trasa, ¾udia
ENDFOR
	\end{lstlisting}
	\caption{Pseudokód algoritmu na získavanie dát pre zoznam ob¾úbenıch destinácií pomocou OGM }
	\label{pseudo-neoeloquent}
\end{algorithm}

\subsection{Databázové dopyty pomocou Cypher klienta}
\noindent Aby sme sa vyhli problému z kapitoly \ref{app-ogm}, rozhodli sme sa implementova dopyty na väèšie sady dát pomocou jedného dopytu v jazyku Cypher. Na vykonanie priameho dopytu sme pouili kninicu \textit{PHP Neo4J Client}. Táto kninica vykonáva dopyty v jazyku Cypher a teda nám poskytuje priamy prístup k Cypher API databázy. 
V príklade \ref{cypher-follows} je dopyt, ktorı nahradzuje celú funkcionalitu kódu z príkladu \ref{pseudo-neoeloquent}.
Dopyt pozostáva z nasledovnıch úkonov (vykonávajú sa po riadkoch):
\begin{enumerate}
	\item Získaj vrchol typu AppUser s ID = 1 a ulo ho do premennej user. Ïalej získaj všetky vrcholy, ku ktorım z vrcholu user vedie hrana typu FOLLOWS a ulo ich do premennej dest.
	\item Získaj vrchol, ku ktorému vedie hrana typu home od vrchola user a ulo ho do premennej home.
	\item Získaj všetky hrany, ktoré vedú od vrchola home do jednotlivıch vrcholov v premennej dest.
	\item Získaj všetky vrcholy, od ktorıch vedie hrana typu FOLLOWS ku všetkım vrcholom v premennej dest. Keïe aj vrchol user má hranu FOLLOWS do kadého vrcholu v dest, vynechaj vrchol user z vıberu.
	\item Definuj formát vıstupu.
\end{enumerate}

\noindent Po vykonaní dopytu sa nám vráti vıstup vo forme tabu¾ky obdobnej, ako pri vykonaní JOIN príkazu v relaènej databáze. Keïe sme na jeden dopyt získali všetky informácie, ktoré potrebujeme na zobrazenie tabu¾ky, nepotrebujeme vykonáva u iadne ïalšie dopyty. Tento prístup zníil priemernú latenciu nášho API na 37\% (695,7ms) oproti prístupu pomocou OGM z kapitoly \ref{app-ogm}


\begin{algorithm} [H]
	\lstset{
		language=PHP,
		basicstyle=\small\sffamily,
		frame=none,
		numbers=left,
		xleftmargin=5.0ex,
		numberstyle=\tiny,
		stepnumber=1,
		showstringspaces=false,
		keywordstyle=\color{blue}\bfseries
	}
	\lstset{emph={% Adjust any special keywords
			printf%
		},emphstyle={\color[rgb]{1,0,0}\bfseries}%
	}%
	\begin{lstlisting}
MATCH (user:AppUser)-[:FOLLOWS]->(dest) WHERE id(user)=1   
MATCH (user)-[:HOME]->(home)
MATCH (home)-[route:ROUTES]->(dest)
MATCH (follower:AppUser)-[:FOLLOWS]->(dest) WHERE follower <> user
RETURN dest, route, follower ;
	\end{lstlisting}
	\caption{Dopyt na dáta pre zoznam ob¾úbenıch destinácií v jazyku Cypher}
	\label{cypher-follows}
\end{algorithm}




\subsection{Implementácia optimalizácie trasy}
\noindent V aplikácií sa nachádza obrazovka, na ktorej si môe pouívate¾ vybra destinácie, pre ktoré by chcel vyráta optimálnu trasu vzh¾adom na cenu. Táto trasa bude zaèína v domovskej destinácii pouívate¾a, prejde všetkımi vybranımi destináciami práve raz a vráti sa spä do domovskej destinácie. Toto je klasickı prípad NP-úplného problému pocestného obchodníka (ïalej TSP). 

Pre jednoduchos a spo¾ahlivos sme implementovali prístup rekurzívneho preh¾adávania všetkıch monosti trás. Implementovali sme rekurzívnu funkciu v PHP, ktorá prejde všetkımi monımi trasami medzi našimi destináciami a vyberie prechod grafom, ktorı je optimálny vzh¾adom na cenu celkovej trasy. Do argumentu berie naša funkcia domovskú destináciu, zoznam destinácií, ktoré ešte nepreh¾adala a domovskú destináciu, do ktorej sa má nakoniec vráti. V kadom vnorení sa zoznam nepreh¾adanıch vrcholov zmenšuje. Vyššie spomenuté argumenty sú perzistentné objekty resp. polia inštancií perzistentnej triedy \textit{Place}.

Keï sa táto funkcia dopytuje na cenu trasy vedúcej zo zaèiatoèného vrchola do cie¾ového, zavolá funkciu, ktorá dá dopyt na našu databázu. Ak sa táto trasa nenachádza v databáze, vypıta si údaje o konkrétnej trase od API Rome2Rio. Keïe kadı dopyt na API trvá cca 200ms, prvé volanie pri väèšej trase trvá nieko¾konásobne dlhšie ako kadé nasledujúce volanie.

Aj po naèítaní všetkıch potrebnıch trás bolo naše riešenie príliš pomalé. U pri siedmych miestach vıpoèet TSP trval a 7 minút. Toto bolo spôsobené tım, e naša funkcia, ktorá poèíta s vıpoètovou zloitosou $O(n!)$, beí na vrstve PHP a pri kadom volaní funkcie invokuje kninicu NeoEloquent, a dopytuje sa na hranu medzi dvoma destináciami. Keï funkcia v takomto reime beala, videli sme, e proces Neo4J konzistentne bral cca 30\% z procesorového èasu. Z tohoto dôvodu sme naimplementovali vyrovnávaciu pamä na dopyt k databáze a priemernı èas sa zníil na 80 sekúnd. 

Naša implementácia front-endu vyaduje dva dopyty na náš server. Jeden na zobrazenie mapy a druhı na zobrazenie tabu¾ky s vısledkami. Z tohoto dôvodu sme pridali ešte jeden level vyrovnávacej pamäte na celé volanie funkcie pre rátanie TSP. Taktie sme upravili implementáciu front-endu tak, aby sa tieto dva dopyty vykonali vdy synchrónne za sebou. Tımto sme zníili nároky na vıpoètové kapacity nášho servera. 

Dlhı èas vıpoètu pri dopytovaní sa na databázu pripisujeme tomu, e naše dopyty na databázu boli diskrétne pri kadom vnorení funkcie. Aj keï sme pouívali perzistentné objekty, implementácia kadého dopytu NeoEloquent pozostáva z jedného dopytu v jazyku Cypher na databázu. Toto volanie obsahuje vyh¾adanie zaèiatoèného a koneèného bodu pod¾a id, so zloitosou $O(log(n))$, a následne vyh¾adanie hrany, so zloitosou $O(1)$. Tento prístup nevyuíva hlavnú vıhodu grafovej databázy, no s pouitím NeoEloquent nie je moné postavi komplexnı dopyt, ktorı by vedel vyrieši TSP za jeden beh. Takıto dopyt je v Neo4J moné implementova pomocou dopytovacieho jazyka Cypher. Príklad takéhoto dopytu môeme vidie v algoritme è.\ref{CypherTSP}. Tento dopyt sme však neimplementovali, kvôli jeho komplexnosti a faktu, e oproti našej funkcii v PHP neposkytuje lepšiu teoretickú vıpoètovú zloitos. 
\begin{algorithm} [H]
	\lstset{
		language=PHP,
		basicstyle=\small\sffamily,
		frame=none,
		numbers=left,
		xleftmargin=5.0ex,
		numberstyle=\tiny,
		stepnumber=1,
		showstringspaces=false,
		keywordstyle=\color{blue}\bfseries
	}
	\lstset{emph={% Adjust any special keywords
			printf%
		},emphstyle={\color[rgb]{1,0,0}\bfseries}%
	}%
	\begin{lstlisting}
MATCH (from:Node {name: "Source node" })
MATCH path = (from)-[:CONNECTED_TO*6]->()
	WHERE ALL(n in nodes(path) WHERE 1 = length(filter(m in
	nodes(path) WHERE m = n)))
AND length(nodes(path)) = 7
RETURN path,
	reduce(distance = 0, edge in relationships(path) | 
		distance + edge.distance)
AS totalDistance
ORDER BY totalDistance ASC
LIMIT 1
	\end{lstlisting}
	\caption{Ukáka riešenia TSP pomocou dopytovacieho jazyka Cypher}
	\label{CypherTSP}
\end{algorithm}




\subsection{Rome2rio API}
\noindent Všetky údaje o destináciách a trasách berieme z API Rome2Rio. Pomocou Autocomplete API umoòujeme pouívate¾ovi pridáva destinácie. Pouívate¾ zadáva písmená do autocomplete textového po¾a na stránke. Toto pole posiela dopyty na Autocomplete API a ono vracia pole objektov s miestami. Tieto objekty obsahujú informácie o type destinácie(obec, mesto, región, štát, letisko,...), geografickú polohu, názov v dlhom a krátkom tvare,	 a kanonickı názov. Pouívate¾ si potom vyberie jednu z destinácií a príslušnı objekt sa zašle na náš server. Na jednoznaènú identifikáciu objektu pouívame kanonickı názov, ktorı je pod¾a dokumentácie unikátnym identifikátorom miesta. 

Ak destináciu ešte nemáme v databáze, pridáme tento objekt do databázy. Toto riešenie nie je úplne ideálne z bezpeènostného h¾adiska, lebo umoòuje zaslanie falošného miesta do našej databázy. Ak by útoèník vyrobil objekt s reálnym kanonickım názvom no falošnımi údajmi napr. o zemepisnej šírke a dåke, toto miesto by sa potom nesprávne zobrazovalo všetkım pouívate¾om. Na vyriešenie tohoto problému by postaèilo urobi ešte jeden dopyt z nášho servera na autocomplete API, ktorım by sme si len vypıtali údaje k miestu za pomoci kanonického názvu.

Ïalšie údaje berieme z Rome2Rio Search API. Sú to údaje o monıch trasách a ich cenách. Toto API je obmedzené na poèet volaní. Preto sme na volanie tohoto API implementovali vyrovnávaciu pamä. Vdy keï voláme Search API, voláme ho na dve miesta ,ktoré u máme uloené v našej databáze ako vrcholy. Tento fakt sme vyuili a vytvorili sme ïalší typ hrany - CACHE. Keïe pri mestách, ktoré sú dopravné uzly vystúpila ve¾kos odpovede API a na rádovo 500kb a tento typ dopytu sa nerobí ve¾mi èasto, rozhodli sme sa odpoveï servera neuklada priamo do databázy, ale v nezmenenej podobe na disk, a do databázy uloi len vek súboru, a referenciu na súbor na disku. Keïe v aktuálnej podobe nevyuívame celú odpoveï tohoto API, mohli by sme optimalizova vyuitie miesta na disku tım, e by sme najprv údaje zapracovali a uloili len tie, ktoré vyuívame.


\subsection{Vykres¾ovanie máp}
\noindent Na vizualizáciu destinácií a trás sme na rôznych miestach a aplikácií pouili javascriptovú kninicu Mapbox.js.

Keïe Mapbox.js rozširuje kninicu Leaflet, všetky funkcie kninice sa volajú z globálneho objektu \textit{L}. Táto funkcia sa zavolá po naèítaní stránky. Keïe sa mapy Mapbox.js sahujú zo serverov Mapbox, musíme najprv aplikáciu identifikova API k¾úèom, ktorı sme si vygenerovali po registrácii. Následne inicializujeme samotnú mapu volaním funkcie \textit{ L.mapbox.map}. Táto funkcia berie, ako prvı parameter id HTML elementu, do ktorého sa má mapa zobrazi, a ako druhı parameter berie textovı identifikátor typu mapy, ktorı chceme zobrazi. Po inicializácii sa vytvorí vrstva pre mapu, ktorá bude obsahova oznaèenia destinácií. Dáta, ktoré obsahujú geografickú polohu destinácií sa vyiadajú vo formáte GeoJson z API našej aplikácie. Keïe pri malom priblíení mapy by sa nedali zrete¾ne rozlíši destinácie, ktoré sú blízko seba, po naèítaní dát vytvoríme vrstvu zoskupení pomocou funkcie \textit{L.MarkerClusterGroup}. Táto vrstva spojí blízke body do zoskupení a následne ukryje znaèky tıchto bodov, a nahradí ich znaèkou zoskupenia. Pri pridávaní bodov do zoskupení sa iteruje cez všetky body, ktoré sú po naèítaní v mape a kadı sa pridá do vrstvy zoskupení. Následne sa vrstva zoskupení pridá do objektu mapy. Vısledok môeme vidie na obrázku \ref{screen-dash}.
Ako zdrojovı formát dát pre všetky mapy v našej aplikácii pouívame štandardnı formát GeoJson. GeoJson je dátová štruktúra zakódovaná do formátu JSON obsahujúca informácie potrebné na vykres¾ovanie kartografickıch velièín. V našej implementácii pouívame nasledovnú štruktúru GeoJson objektu. Hlavnı objekt GeoJson obsahuje typ, v našom prípade \textit{FeatureCollection} a pole objektov typu \textit{Feature}. Kadı z tıchto objektov obsahuje pole súradníc a objekt dodatoènıch atribútov slúiacich na upresnenie vizuálu vykresleného objektu. Dané pole súradníc nám spôsobovalo mierne nedorozumenia, lebo v èíslovanom poli je, ako prvı prvok uloená zemepisná dåka (longitude), a ako druhı prvok zemepisná šírka (latitude) \cite{geojson}, èo je presne opaène, ako všetky ostatné API, ktoré sme pouívali.


\subsection{Vykres¾ovanie tabuliek}
\noindent Aby sme zlepšili UX stránky rozhodli sme sa na vykres¾ovanie dynamického obsahu vyui namiesto HTML obsahu renderovaného na serveri, javascriptovú kninicu na prácu so šablónami a dynamickı obsah naèítavame z API našej aplikácie vo formáte JSON. Na vykres¾ovanie dynamického obsahu sme si zvolili kninicu Handlebars.js. 

Najprv je zadeklarovaná premenná v \textit{template}, ktorá bude neskôr obsahova funkciu renderujúcu šablónu. Potom je zadeklarovaná funkcia \textit{refreshPage}, ktorá bude volaná vdy, keï nejaká funkcia vyvolá udalos s menom \textit{appRefresh}. Táto funkcia vyuije AJAX API kninice jQuery a stiahne potrebné dáta. Potom vyuije funkciu \textit{template}, ktorá do argumentu zoberie dáta vo forme po¾a objektov a vráti vygenerované HTML, ktoré sa následne vkladá na stránku.

V druhej èasti kódu sa najprv volá funkcia \textit{Handlebars.compile} a do argumentu zoberie šablónu, ktorá je uloená v elemente s id \textit{places-template}. Ako návratovú hodnotu vráti funkciu, ktorú uloíme pod menom \textit{template}. Následne sa na udalos \textit{appRefresh} naviae volanie funkcie \textit{refreshPage} a prvıkrát sa zavolá táto udalos.

Naša šablóna \textit{places-template} obsahuje aj aktívne linky a v nasledujúcom bloku je príklad implementácie vymazania miesta z ob¾úbenıch. Na všeobecnú udalos \textit{click} je naviazaná filtrovaná udalos, ktorá spustí AJAX dopyt na vymazanie miesta z ob¾úbenıch, ak element, ktorı udalos vyvolal obsahuje triedu \textit{delete} a atribút \textit{data-id}.



\subsection{Pouívate¾ské rozhranie}
\noindent Pouívate¾ské rozhranie je implementované pomocou HTML, CSS a JavaScript. Pouili sme CSS framework Bootstrap pre zabezpeèenie responzivity a konzistentného vızoru, a UX aplikácie. Vo vrchnej èasti rozhrania sa nachádza navigaènı panel.

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{img/screen-dash.png}
	\caption{Ukáka hlavnej obrazovky pouívate¾a}
	\label{screen-dash}
\end{figure}
Na hlavnej obrazovke (obrázok è.\ref{screen-dash}) je v navigaènom paneli pridané textové pole na pridávanie destinácií na zoznam ob¾úbenıch. V hlavnej èasti aplikácie sa nachádza mapa s vyobrazenımi destináciami zo zoznamu, ïalej tabu¾ka s destináciami, kde si môe pouívate¾ rozbali detaily konkrétnej destinácie alebo ju zmaza a tabu¾ka s odporúèanımi destináciami, ktoré si môe pouívate¾ prida do svojho zoznamu.


\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{img/screen-tsp.png}
	\caption{Ukáka obrazovky TSP}
	\label{screen-tsp}
\end{figure}
Na obrazovke TSP (obrázok è.\ref{screen-tsp}) sa nachádza mapa s reprezentáciou optimálnej trasy. Na mape sú znaèky pospájané priamkami, oèíslované pod¾a poradia, v akom ich má pouívate¾ navštívi na dosiahnutie optimálnych nákladov.
Nišie je tabu¾ka s podrobnejším opisom trasy s vymenovanımi spôsobmi dopravy. V spodnej èasti stránky je zoznam ob¾úbenıch destinácií, z ktorıch môe destinácie pridáva a odobera zo zoznamu na optimalizáciu.


\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{img/screen-settings.png}
	\caption{Ukáka obrazovky Nastavenia}
	\label{screen-settings}
\end{figure}
Na obrazovke nastavení sa nachádza mapa, ktorá vyobrazuje aktuálne domáce miesto pouívate¾a. Pod òou sa nachádza textové pole, pomocou ktorého môe pouívate¾ vyh¾ada a nastavi domáce miesto. V spodnej èasti obrazovky nastavení je sekcia, kde si môe pouívate¾ zmeni heslo.

\section{Testovanie}
\label{speedtest}
\noindent Všetky testy sme vykonávali na našom serveri s Ubuntu 16.04.2 LTS s jednım virtuálnym jadrom a 4GB RAM. Testovali sme na databáze Neo4j Community verzia 3.1.4 a na databáze MYSQL verzia 5.7.18. Tabu¾ky boli uloené pomocou InnoDB. Pri testovaní rıchlosti naša aplikácia beala na serveri Apache verzia 2.4.18 s interpreterom PHP verzia 7.0.15.

Ako sadu dát sme pouili reálne dáta o destináciách a trasách z Rome2Rio API. Aby sme zabezpeèili zvyšovanie, ako ve¾kosti, tak aj hustoty grafu, zaèali sme s jednım pouívate¾om s desiatimi polokami. V druhom kroku sme pridali pouívate¾a s pädesiatimi destináciami, ktorı mal zároveò pridané všetky destinácie prvého pouívate¾a a takto sme pokraèovali a po poèet destinácií 1400. Dáta sme generovali našou aplikáciou a následne migrovali do MYSQL databázy štruktúrovanou, ako v našom návrhu opísaného v kapitole \ref{db-struct}.


\subsection{Latencia databázy Neo4j a MySQL}
\label{chap-test}
Prvı test, ktorı sme robili bol syntetickı test rıchlosti komplexného dopytu na databázu. Cie¾om testu bolo porovna škálovate¾nos relaènej a grafovej databázy v prípadoch podobnıch nášmu. Dopyt, ktorého latenciu sme testovali bol na zozname ob¾úbenıch destinácií. Ku kadej destinácii sme vyh¾adali ešte trasu, ktorá k nej vedie z domovskej destinácie pouívate¾a a zoznam ostatnıch pouívate¾ov, ktorı tie majú túto destináciu na zozname. Dopyt v databáze Neo4J môeme vidie na algoritme \ref{cypher-follows}. Dopyt v databáze MYSQL môeme vidie na algoritme \ref{sql-follows}.

\begin{algorithm} [H]
	\lstset{
		language=SQL,
		basicstyle=\small\sffamily,
		frame=none,
		numbers=left,
		xleftmargin=5.0ex,
		numberstyle=\tiny,
		stepnumber=1,
		showstringspaces=false,
		keywordstyle=\color{blue}\bfseries
	}
	\lstset{emph={% Adjust any special keywords
			printf%
		},emphstyle={\color[rgb]{1,0,0}\bfseries}%
	}%
	\begin{lstlisting}
SELECT * FROM `follows` f 
LEFT JOIN `place` p ON f.`id_place` = p.`id` 
LEFT JOIN `routes` r ON r.`id_from` = u.`id_home` 
AND r.`id_to` = p.`id`
LEFT JOIN `follows` fo ON fo.`id_place` = p.`id` 
LEFT JOIN `users` u ON u.id = fo.`id_user`
LEFT JOIN `tsp` t ON t.`id_user` = f.`id_user` 
AND t.`id_place` = f.`id_place`
WHERE f.`id_user` = 231
	\end{lstlisting}
	\caption{SQL dopyt pre testovanie rıchlosti}
	\label{sql-follows}
\end{algorithm}

%TODO vyhodi tabu¾ku?
\begin{table}[H]
	\centering
	\caption{Vısledky testu rıchlosti API pre zobrazenie zoznamu ob¾úbenıch destinácií}
	\label{speed-table-sql}
	\begin{tabular}{|l|l|l|l|l|l|l|l|}
		\hline
		Poèet poloiek& 10   & 50   & 100  & 200  & 500   & 1000   & 1400   \\ \hline
		Cypher shell  & 6,7  & 25,2 & 32   & 54   & 99,8  & 162,7  & 248,9  \\ \hline
		SQL           & 15,5 & 16,1 & 31,6 & 62,5 & 387,3 & 1339,8 & 2396,6 \\ \hline
	\end{tabular}
\end{table}

\begin{figure}[H]
	\centering
	\includegraphics[width=14cm]{img/speed-sql.pdf}
	\caption{Vısledky testu rıchlosti API pre zobrazenie zoznamu ob¾úbenıch destinácií}
	\label{speed-plot-sql}
\end{figure}

Na vısledkoch testov v tabu¾ke  vidíme, e pri zväèšovaní a zahusovaní grafu latencia databázy MySQL rastie ove¾a rıchlejšie ako Neo4j. Pri 1400 záznamoch vystúpala priemerná latencia a na 2,3966 sekundy. Tento rıchly nárast latencie MySQL prisudzujeme rastu ve¾kosti spájacích tabuliek, ktorıch preh¾adávanie je hlavnou príèinou spomalenia relaènej databázy pri preh¾adávaní sady dát so zloitou štruktúrou s mnohımi vzahmi. Na rozdiel od toho databáza Neo4J dosahovala pri rovnakej dátovej sade priemernú latenciu 248,9ms. Tieto vısledky ukazujú vhodnos pouitia grafovej databázy oproti relaènej pre prípad pouitia, kde má dátová sada štruktúru grafu. 

\subsection{Latencia rôznych prístupov k databáze Neo4J}
Druhı test, ktorı sme robili bol reálny test latencie nami implementovaného API v dvoch verziách. V prvej verzii s pouitím OGM a v druhej s pouitím PHP Neo4J Client. Tento test sme vykonali, ako súèas implementácie, aby sme vedeli posúdi, ktoré riešenie pouijeme vo finálnej verzii aplikácie. 
Pri teste sme pouívali rovnakú dátovú sadu, ako v prvom teste. Latenciu sme merali tak, e sme posielali dopyty na naše API pre vykreslenie zoznamu ob¾úbenıch destinácií a zaznamenávali sme èas od doruèenia dopytu na server do zaèiatku sahovania dát. Test sme opakovali desa krát. 

V tabu¾ke è.\ref{speed-neo-table} vidíme priemernú latenciu nášho API v závislosti od poètu poloiek na zozname. Dáta sú ïalej vizualizované v grafe na obrázku è.\ref{speed-neo-plot}. Z vısledku nášho testu sme usúdili, e prístup pomocou OGM nebol schopnı vyui plnı potenciál našej grafovej databázy a rozhodli sme sa vo finálnej verzii zmeni implementáciu na prístup pomocou PHP Neo4j Client.

\begin{table}[H]
	\centering
	\caption{Vısledky testu rıchlosti API pre zobrazenie zoznamu ob¾úbenıch destinácií}
	\label{speed-neo-table}
	\begin{tabular}{|l|l|l|l|l|}
		\hline
		Poèet poloiek	 & 10    & 50    & 100   & 200   \\ \hline
		NeoEloquent      & 101,6 & 281,7 & 705,7 & 1857  \\ \hline
		PHP neo4j client & 83,2  & 195   & 358,5 & 695,7 \\ \hline
	\end{tabular}
\end{table}

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{img/speed.pdf}
	\caption{Vısledky testu rıchlosti API pre zobrazenie zoznamu ob¾úbenıch destinácií}
	\label{speed-neo-plot}
\end{figure}


\section{Zhodnotenie}
\noindent V tejto kapitole sa budeme venova zhodnoteniu vısledkov našej implementácie a celkovému zhrnutiu vısledkov nášho testovania.

\subsection{Zhodnotenie implementácie}
\noindent Ako súèas práce sme implementovali aplikáciu na plánovanie a optimalizáciu trasy cestovate¾a. Aplikácia obsahuje registráciu a prihlásenie pouívate¾a. Po prihlásení si pouívate¾ môe vyh¾ada a prida destinácie na svoj zoznam ob¾úbenıch. Pri zobrazovaní zoznamu aplikácia poskytuje informácie o trasách vedúcich z konkrétnych destinácií do konkrétnych destinácií vrátane informácií o cene a spôsobe dopravy, a informáciu o tom, akí ïalší pouívatelia majú tie destináciu na zozname.  Ïalej aplikácia na základe u pridanıch destinácií zobrazuje pouívate¾ovi zoznam odporúèanıch destinácií.  Všetky tieto údaje sú dopytované pomocou rıchlejšieho prístupu k databáze pomocou PHP Neo4J Client. 

Ïalej je v aplikácii obrazovka na optimalizáciu trasy. Na tejto obrazovke si pouívate¾ zo svojho zoznamu môe vybra niektoré destinácie a aplikácia mu vráti poradie, v akom by mal pouívate¾ navštívi zvolené destinácie pre optimalizovanie nákladov na cestu. Pre nedostatok èasu a zloitos tohoto vıpoètu sme implementáciu optimalizácie nechali v staršej verzii – s pouitím prístupu k databáze pomocou OGM. Aby sme zlepšili UX pouívate¾a, implementovali sme nieko¾ko vrstiev vyrovnávacej pamäte, aby sa vısledky zobrazovali, èo najskôr. 

\subsection{Zhodnotenie testovania}
\noindent Po fáze implementácie sme testovali latenciu našich dopytov na databázu. Testy sme porovnávali s obdobnımi testami na rovnakıch dátach v databáze MySQL. Pri testoch sme dokázali, e grafová databáza má aj v našom reálnom  príklade merate¾ne vyšší vıkon pri práci s grafovou sadou dát ve¾kosti nieko¾ko sto vrcholov a hrán. Potvrdili sme teda lepšiu škálovate¾nos grafovej databázy.

%TODO DEVELOPER EXPERIENCE
\subsection{Zhodnotenie skúseností s vıvojom pomocou grafovej databázy}
\noindent Natívna štruktúra pouitej grafovej databázy prirodzene poòala našu sadu dát bez potreby dáta trasnformova èi rozdelova do tabuliek. Flexibilita bezshémovej grafovej databázy nám oproti relaènım databázam poskytla monos rıchlo iterova, testova variácie v štruktúre našej databázy.

Grafová databáza Neo4J ïalej poskytuje jednoduché a pritom silné nástroje na prácu s grafmi. Nástroje, ako jednoduchı a silnı dopytovací jazyk Cypher, a pouívate¾ské rozhranie databázy s preh¾adnımi interaktívnymi vizualizáciami dát pomohli zmierni krivku uèenia spojenú s novım typom databázy.